<!DOCTYPE html>
<html>
<head>
    <title>MONSTER TRUCK STADIUM</title>
    <link rel="icon" href="data:,">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #120023;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            color: #fff;
            text-align: center;
            z-index: 100;
            font-size: 16px;
            text-shadow: 0 0 5px #ff00ff;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ff00ff;
            font-size: 14px;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ffff;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ff00ff;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="info">
        MONSTER TRUCK STADIUM
    </div>
    
    <div id="controls">
        <p>Up/Down: Accelerate/Brake</p>
        <p>Left/Right: Steer</p>
        <p>W/S: Camera Height</p>
        <p>A/D: Camera Distance</p>
        <p>CRASH STUFF!</p>
        <p>• Drive up big ramps for air</p>
        <p>• Crash into small blocks to destroy them</p>
        <p>• Bounce off big towers and walls</p>
    </div>
    
    <div id="score">SCORE: 0</div>
    
    <div style="position: absolute; bottom: 20px; right: 20px; color: #fff; background-color: rgba(0, 0, 0, 0.6); padding: 10px; border-radius: 5px; border: 1px solid #ff00ff;">
        <label for="musicToggle" style="cursor: pointer; user-select: none;">
            <input type="checkbox" id="musicToggle" checked> 80s Synthwave
        </label>
        <input type="range" id="volumeSlider" min="0" max="100" value="50" style="width: 100px; margin-left: 10px;">
    </div>

    <!-- Audio elements for MP3 playback -->
    <audio id="bgMusic" loop preload="auto">
        <source src="Micah Smith - Bubble Bath.mp3" type="audio/mpeg">
    </audio>
    
    <!-- Crowd sounds (base64 encoded due to lack of actual sound file) -->
    <audio id="crowdCheers" preload="auto">
        <source src="data:audio/mp3;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFzdC5mbSBTb3VuZCBQb29sAAAAL1RDT04AAAAFTWl4ZWQATElTVAAAA0VuZwBUWUVSAAAABTIwMTkAVERSQwAAAAVNaXhlZAA=" type="audio/mpeg">
    </audio>
    <audio id="crowdOohs" preload="auto">
        <source src="data:audio/mp3;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFzdC5mbSBTb3VuZCBQb29sAAAAL1RDT04AAAAFTWl4ZWQATElTVAAAA0VuZwBUWUVSAAAABTIwMTkAVERSQwAAAAVNaXhlZAA=" type="audio/mpeg">
    </audio>
    
    <!-- Music selection prompt -->
    <div id="musicPrompt" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
         background-color: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; border: 2px solid #ff00ff; 
         color: white; text-align: center; display: none; z-index: 1000;">
        <h3 style="color: #00ffff; margin-top: 0;">Choose Music Option</h3>
        <button id="startMp3Btn" style="background: #ff00ff; color: white; border: none; padding: 10px 20px; 
                margin: 10px; cursor: pointer; border-radius: 5px; display: block; width: 200px;">
            MP3 Track
        </button>
        <button id="startGeneratedBtn" style="background: #00ffff; color: black; border: none; padding: 10px 20px; 
                margin: 10px; cursor: pointer; border-radius: 5px; display: block; width: 200px;">
            Generated Synthwave
        </button>
        <button id="startNoMusicBtn" style="background: #333; color: white; border: none; padding: 10px 20px; 
                margin: 10px; cursor: pointer; border-radius: 5px; display: block; width: 200px;">
            No Music
        </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // Improved monster truck game with realistic driving controls
    let scene, camera, renderer, truck;
    let score = 0;
    let groundMeshes = [];
    
    // Control variables
    const keys = {};
    const truckSpeed = {
        x: 0,
        z: 0
    };
    
    // Camera settings for larger arena
    const cameraSettings = {
        height: 30,
        distance: 50,
        angle: 0.3
    };
    
    function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x120023); // Dark purple background
        
        // Create camera with angled view
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 30); // Set initial position directly
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xff00ff, 0.8);
        directionalLight.position.set(0, 50, 20);
        scene.add(directionalLight);
        
        // Create ground with grid
        createGround();
        
        // Create obstacles
        createObstacles();
        
        // Create boundary walls
        createBoundary();
        
        // Create the monster truck
        createTruck();
        
        // Set up controls
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize);
        
        // Set up music controls
        setupMusic();
        
        // Start animation loop
        animate();
    }
    
    // Music system variables
    let audioContext = null;
    let gainNode = null;
    let oscillator = null;
    let musicPlaying = false;
    let musicMode = 'none'; // 'mp3', 'generated', or 'none'
    
    function setupMusic() {
        const musicToggle = document.getElementById('musicToggle');
        const volumeSlider = document.getElementById('volumeSlider');
        const musicPrompt = document.getElementById('musicPrompt');
        const startMp3Btn = document.getElementById('startMp3Btn');
        const startGeneratedBtn = document.getElementById('startGeneratedBtn');
        const startNoMusicBtn = document.getElementById('startNoMusicBtn');
        const bgMusic = document.getElementById('bgMusic');
        
        // Set toggle to not checked initially
        musicToggle.checked = false;
        
        // Set initial volume
        bgMusic.volume = volumeSlider.value / 100;
        
        // Make sure all DOM elements exist before showing prompt
        if (musicPrompt && startMp3Btn && startGeneratedBtn && startNoMusicBtn) {
            // Show music prompt after a short delay
            setTimeout(() => {
                musicPrompt.style.display = 'block';
            }, 500);
        } else {
            console.error("Missing music UI elements");
        }
        
        // Safely set up event listeners
        if (startMp3Btn) {
            startMp3Btn.addEventListener('click', () => {
                if (musicPrompt) musicPrompt.style.display = 'none';
                musicMode = 'mp3';
                startMp3Music();
                if (musicToggle) musicToggle.checked = true;
            });
        }
        
        if (startGeneratedBtn) {
            startGeneratedBtn.addEventListener('click', () => {
                if (musicPrompt) musicPrompt.style.display = 'none';
                musicMode = 'generated';
                startSynthMusic();
                if (musicToggle) musicToggle.checked = true;
            });
        }
        
        if (startNoMusicBtn) {
            startNoMusicBtn.addEventListener('click', () => {
                if (musicPrompt) musicPrompt.style.display = 'none';
                musicMode = 'none';
                if (musicToggle) musicToggle.checked = false;
            });
        }
        
        // Toggle music on/off
        if (musicToggle) {
            musicToggle.addEventListener('change', () => {
                if (musicToggle.checked) {
                    // Resume current music mode or default to MP3
                    if (musicMode === 'generated') {
                        if (!musicPlaying) startSynthMusic();
                    } else {
                        // Default to MP3 if no mode selected yet
                        if (musicMode === 'none') musicMode = 'mp3';
                        startMp3Music();
                    }
                } else {
                    // Stop all music
                    stopAllMusic();
                }
            });
            
            // Add music type selector - right-click toggles between MP3 and generated
            musicToggle.addEventListener('contextmenu', (e) => {
                e.preventDefault(); // Prevent context menu
                
                if (musicToggle.checked) {
                    stopAllMusic();
                    
                    // Toggle between MP3 and generated
                    if (musicMode === 'mp3') {
                        musicMode = 'generated';
                        startSynthMusic();
                    } else {
                        musicMode = 'mp3';
                        startMp3Music();
                    }
                }
                
                return false;
            });
        }
        
        // Adjust volume for both audio systems
        if (volumeSlider && bgMusic) {
            volumeSlider.addEventListener('input', () => {
                const volume = volumeSlider.value / 100;
                
                // For Web Audio API
                if (gainNode) {
                    gainNode.gain.value = volume;
                }
                
                // For HTML5 Audio
                bgMusic.volume = volume;
            });
        }
    }
    
    function startMp3Music() {
        // Stop any generated music first
        stopSynthMusic();
        
        // Play the MP3
        const bgMusic = document.getElementById('bgMusic');
        
        try {
            const playPromise = bgMusic.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.log("MP3 playback failed:", error);
                    
                    // If MP3 fails, fall back to generated music
                    musicMode = 'generated';
                    startSynthMusic();
                });
            }
        } catch (e) {
            console.error("MP3 playback error:", e);
            
            // If MP3 fails, fall back to generated music
            musicMode = 'generated';
            startSynthMusic();
        }
    }
    
    function stopAllMusic() {
        // Stop MP3
        const bgMusic = document.getElementById('bgMusic');
        bgMusic.pause();
        bgMusic.currentTime = 0;
        
        // Stop generated music
        stopSynthMusic();
    }
    
    // Generate synthwave-like music programmatically using Web Audio API
    function startSynthMusic() {
        try {
            // Create audio context if it doesn't exist
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create gain node for volume control
                gainNode = audioContext.createGain();
                gainNode.gain.value = document.getElementById('volumeSlider').value / 100;
                gainNode.connect(audioContext.destination);
            }
            
            // Create synthwave-like bass
            createSynthBassPart();
            
            // Create synthwave-like lead arpeggio
            setTimeout(() => {
                createSynthLeadPart();
            }, 1000);
            
            musicPlaying = true;
        } catch (e) {
            console.error("Web Audio API error:", e);
        }
    }
    
    function createSynthBassPart() {
        // Base notes for synthwave
        const notes = [
            { note: 55, duration: 0.5 }, // G
            { note: 55, duration: 0.5 },
            { note: 62, duration: 0.5 }, // D
            { note: 55, duration: 0.5 },
            { note: 58, duration: 0.5 }, // A#
            { note: 55, duration: 0.5 },
            { note: 53, duration: 0.5 }, // F
            { note: 55, duration: 0.5 }
        ];
        
        let currentIndex = 0;
        
        function playNextNote() {
            if (!musicPlaying) return;
            
            const note = notes[currentIndex];
            const osc = audioContext.createOscillator();
            const noteGain = audioContext.createGain();
            
            // Set up oscillator
            osc.type = 'sawtooth';
            osc.frequency.value = note.note;
            
            // Set up envelope
            noteGain.gain.value = 0;
            noteGain.gain.setValueAtTime(0, audioContext.currentTime);
            noteGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01);
            noteGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.2);
            noteGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + note.duration);
            
            // Connect nodes
            osc.connect(noteGain);
            noteGain.connect(gainNode);
            
            // Play note
            osc.start();
            osc.stop(audioContext.currentTime + note.duration);
            
            // Schedule next note
            currentIndex = (currentIndex + 1) % notes.length;
            setTimeout(playNextNote, note.duration * 1000);
        }
        
        // Start playing
        playNextNote();
    }
    
    function createSynthLeadPart() {
        // Lead notes for synthwave arpeggio
        const notes = [
            { note: 440, duration: 0.125 }, // A4
            { note: 554, duration: 0.125 }, // C#5
            { note: 659, duration: 0.125 }, // E5
            { note: 880, duration: 0.125 }, // A5
            { note: 659, duration: 0.125 }, // E5
            { note: 554, duration: 0.125 }, // C#5
            { note: 440, duration: 0.125 }, // A4
            { note: 329, duration: 0.125 }  // E4
        ];
        
        let currentIndex = 0;
        
        function playNextNote() {
            if (!musicPlaying) return;
            
            const note = notes[currentIndex];
            const osc = audioContext.createOscillator();
            const noteGain = audioContext.createGain();
            
            // Set up oscillator
            osc.type = 'square';
            osc.frequency.value = note.note;
            
            // Set up envelope
            noteGain.gain.value = 0;
            noteGain.gain.setValueAtTime(0, audioContext.currentTime);
            noteGain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
            noteGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + note.duration);
            
            // Connect nodes
            osc.connect(noteGain);
            noteGain.connect(gainNode);
            
            // Play note
            osc.start();
            osc.stop(audioContext.currentTime + note.duration);
            
            // Schedule next note
            currentIndex = (currentIndex + 1) % notes.length;
            setTimeout(playNextNote, note.duration * 1000);
        }
        
        // Start playing
        playNextNote();
    }
    
    function stopSynthMusic() {
        musicPlaying = false;
    }
    
    function createGround() {
        // Create a much larger flat ground (4x bigger)
        const groundSize = 800;
        
        // Dirt ground texture
        const dirtTexture = new THREE.TextureLoader().load('data:image/png;base64,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');
        const grassTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAH1ElEQVR4nO2dW3IbOQyGpfFumpkkK0lW0uwk2Um8k3gnTXaSdCfNSupTHxockiAIEiAl9n/OqWrsmrFFfCD4g5R0c3d3d7N0ERbm5ubmZpzzRf8Jt83Sf+DGWQKKCUnw8PBQLkBingTw+Ph4c3t7e6MnACQBh5xAQ3pLDnLTb+7u7q5tJXAAOgla7gKOXBlu7u7uDgQcuTL89iVNUoCDTIKRu0AmgUSC3hVgFuCPA4K14AjnTA+en5/fz/v09HRQgiPBJsG9CvD25jhKIEiA9T1mIVSlEUrQqgt0rwCQBAxonPG+N3Dtp4KeX17/SCCV7pO/KmBJAVLzkBJAFeBBgk/3T9lzWO/t8fExrtKYtQLUXj4kAXTCeW0D0N8rFcDt92XlFUBDgqgKkGoT1FSA1A0sSQDdoPf6+vr+efhzSQJTCQoowIe3p5CgpArg60KpLmCqCigSzFIBtKXnbAFYAq7WgKuDTwJfD15npUFyeEgC+BqTUoCX1/m5DFSA1L0wkcFMASAJcisBIoEkgaaGoBlUgBQSCaKFgucqgF/3QoLa75m3AiAStJFAEkBbCbJIUCrB6pNAmNQxnq/1t4ZWAIsKgEeByQrQ+/ciKsCgFWB8rxYJeiVBOAUorQCpqlJCgtIKkJofrwIsHRQ6EveNE3A+BQgpgffgbwYJPkMFwCQoUSYiBYgmAUaEpZNAXQHOXQGg93stEa0rsUkQPisoSYJaGDaJBKkhpTXfQ/WUL/cEcjuGpWHguIJIJIjdbtB0BC1VUJKgJDcRKDVw9UGhuLVbfv5ZFWBNEkgkiJYHSCmAZwlyJShlLxJoqsBpOoKIBF6TQBBfVVJZDBNBYRUAksA7jcGfL9UlXKsEoRSAqwARJAglAdUFzCUB1wUM+6wgQoKl2gAnV4CCJIgmAXauoEqQk5cwUYA1SXDqLuDSSaAaCQZLIJFAUphT7x5SEni+BnC5IFMBiiVYQgGsvnMWEozJofP0A3ISQfB5wZxq4FEBsBjBs5IgdSpaNQroVYJaEmAKUNoPOJtlYUiCFl3ApUkwlgS9Aiw+LVwiAScB3A/wJAGWhOpaAfaUAJOgNgx8eirYswS1JMCGglYlgTfTwmYlwczBoi0JvHUDOztXgBoJqH5AzLsCeJSgJBkEtQFOvSvYqwQ5JGjSBSw9XpAE4/HyooBuJRhEBPCUHUHvEuQ+LwjeP4A2glqRYC0K4FGCVFYwZzm42oCQFxL0UgVySYB1AaECDPBYOQnWoACWJMjJC6jbAB4laKkAe0vQOi/QZTJoDwlqSYBJgOUCVDaIlKoAOa+VSjDkbgzZlQRWFcBCgvE4kAJEIYEXBbAkQUkhiJMAXgfYU4I9FeBcJPCYCEIrQJEEDhTAigRcK1itAJYSrF0BLCTAbhQZrAYWS/CVMQlC9AGoY+4pwZoVwEICrMXnJJBKMFgkgiBJakmwZgWwkoCrAHgUMJYEuAlkuQpYS7BGBbCSwEkSCJMAk4C7FlCiBIhH0RRgDQ8NsZJAKgGcBFgSCCqBFQnWpgAtJBi/mzMM7E4CSwmwNkFuMihsEmjpZFApCZRtAC8kWIsCGEsweyyBVYCSJNBaFGAtCpBDgiYKYLkfYLkKmJPAiwJYSLDbWGJUAaSSaSlB7qrgrBWAkoB7kEQtEsx9sARXAbLnBeSSwJMCWEiQvSNorgpwsgpQsivIgwJYSGC6GshKgpokaLkjKHdnUOlTRNauABYSJJNAYqnECVUB9pSgVAFySdB1G6A3CXIrwNnGAXqRIJcEVRUgR4LeBx0Fz4gWjwNAEmCbQp++ffuUO2+zCoCtC7haBs5MAmwUsJbEvSqAhQTQtWJVICuLp6kAniXoNQpI5QXOviMoRwJoVZDIAtbSrQKkkiCtJIgZSuD5qeK5JLioBJAklgRrVgBKApEEKgXwuClEI0EvCrB0XIBIkBwFtEoCjQJEkWAJBYgiQakCrEYBjiWBugKsSQKVAkSRQEuC5ipwrhJoFKBXCQY0EWQtQU5BiNbvz+KnYrT9gNYkUPUDKg4V1ZYgOggUKWuXCrCGfAAmQdNl4ZwkELSBvO0LGGaZtyTBGDLmpCDCJIMyJEhWALEChJPASwUo/P7sJFAlgGKRYKkK4EGCnuICc0hQpAChJAhWAU6ZBGqeC9iLBMVRwCclQVUFsJBAIwF8rhBWhFklAbcraI0KsLsEaALIe0eQMwnyJYgmQXEVaClBMAWwlEDQBuKeCcQuwPTL/95UcYs2wN4SIAkgdkKohQRVCmBJglQUcDYJqrqAl5Igh1CSqCQYEoOeS4zQlQR1VaBnCbxUgLyStJMgKwnUiwK4kMBjG2BpCQY1CfxJ4LEC7C5BDRK0fVaQ5irCxSXwHgdwcQmqksCcBJFIsLoKcBYSaLqAFj9Bk0sCqgToHkDsfGnPFZxNAmrHgwRRFUBbgrBJoBQJYAniKUBUCcJVAEoCyG8JuJXAf2axBNFIECEKoKRxL4FZAo2oCbibyE0C5SaBvEvQTILJayu6gLETt5gEnLHnBQrQUgLv+NjAE3UHWbeQm4RvLNdL5eWt4yVyBckKQCWA/NzAaSyKiXkWF8DFBgpIAC1KDRfQRQQJ8H9Ey8Kh14ckwL8/Pz+/f6dlk5AIAJKA2hKOSSC1X1rG14dfs9pgFSCqBD8AsRtZL99hb/UAAAAASUVORK5CYII=');
       
        // Create a textured ground with dirt and grass patches
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            map: dirtTexture,
            roughness: 0.8,
            metalness: 0.2,
            side: THREE.DoubleSide
        });
        
        // Add randomness to vertices for terrain variation
        const vertices = groundGeometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            // Skip the edges to keep a flat border
            const xPos = vertices[i];
            const zPos = vertices[i+2];
            const distFromCenter = Math.sqrt(xPos * xPos + zPos * zPos);
            if (distFromCenter < groundSize * 0.45) {
                // Add small height variations
                vertices[i+1] = Math.random() * 0.8;
            }
        }
        groundGeometry.attributes.position.needsUpdate = true;
        groundGeometry.computeVertexNormals();
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        groundMeshes.push(ground);
        
        // Add grass patches
        for (let i = 0; i < 100; i++) {
            const patchSize = 20 + Math.random() * 40;
            const patchGeometry = new THREE.PlaneGeometry(patchSize, patchSize);
            const patchMaterial = new THREE.MeshStandardMaterial({
                map: grassTexture,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            
            const patch = new THREE.Mesh(patchGeometry, patchMaterial);
            patch.rotation.x = -Math.PI / 2;
            patch.position.set(
                (Math.random() - 0.5) * groundSize * 0.9,
                0.2,
                (Math.random() - 0.5) * groundSize * 0.9
            );
            scene.add(patch);
        }
    }
    
    function createObstacles() {
        // Store destructible obstacles
        const destructibleObstacles = [];
        // Store big blocks that you bounce off of
        const bigBlocks = [];
        
        // Create larger ramps that can be driven up
        const ramps = [
            { pos: [100, 5, 150], size: [50, 10, 30], angle: -Math.PI / 15 },
            { pos: [-120, 8, -180], size: [60, 16, 40], angle: -Math.PI / 12 },
            { pos: [-50, 6, 200], size: [45, 12, 35], angle: -Math.PI / 14 },
            { pos: [200, 7, -100], size: [55, 14, 38], angle: -Math.PI / 13 }
        ];
        
        // Add all ramps
        ramps.forEach(rampData => {
            const rampGeometry = new THREE.BoxGeometry(rampData.size[0], rampData.size[1], rampData.size[2]);
            const rampMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff,
                shininess: 30,
                specular: 0xffffff
            });
            const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
            ramp.position.set(rampData.pos[0], rampData.pos[1] / 2, rampData.pos[2]);
            ramp.rotation.x = rampData.angle;
            scene.add(ramp);
            groundMeshes.push(ramp);
            
            // Add neon edge to ramp
            const edgeGeometry = new THREE.BoxGeometry(rampData.size[0] + 0.5, 0.8, rampData.size[2] + 0.5);
            const edgeMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
            // Position just above the ramp
            edge.position.set(
                rampData.pos[0], 
                rampData.pos[1] / 2 + rampData.size[1] / 2 + 0.4, 
                rampData.pos[2]
            );
            edge.rotation.x = rampData.angle;
            scene.add(edge);
        });
        
        // Add small destructible obstacles
        for (let i = 0; i < 40; i++) {
            const size = 3 + Math.random() * 5;
            const x = (Math.random() - 0.5) * 700;
            const z = (Math.random() - 0.5) * 700;
            
            if (Math.abs(x) > 50 || Math.abs(z) > 50) { // Don't place too close to spawn
                // Create a group to hold the obstacle pieces
                const obstacleGroup = new THREE.Group();
                obstacleGroup.position.set(x, size/2, z);
                
                // Create the main box
                const boxGeometry = new THREE.BoxGeometry(size, size, size);
                const boxMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff33cc,
                    shininess: 50,
                    specular: 0xffffff
                });
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                obstacleGroup.add(box);
                
                // Store box pieces for explosion
                const pieces = [];
                const pieceSize = size / 2;
                
                // Create 8 smaller boxes that will become the explosion pieces
                for (let px = -1; px <= 1; px += 2) {
                    for (let py = -1; py <= 1; py += 2) {
                        for (let pz = -1; pz <= 1; pz += 2) {
                            const pieceGeometry = new THREE.BoxGeometry(pieceSize, pieceSize, pieceSize);
                            const pieceMaterial = new THREE.MeshPhongMaterial({ 
                                color: 0xff33cc,
                                shininess: 50, 
                                transparent: true,
                                opacity: 1
                            });
                            const piece = new THREE.Mesh(pieceGeometry, pieceMaterial);
                            piece.position.set(
                                px * pieceSize / 2,
                                py * pieceSize / 2,
                                pz * pieceSize / 2
                            );
                            piece.visible = false; // Hidden initially
                            obstacleGroup.add(piece);
                            pieces.push({
                                mesh: piece,
                                direction: new THREE.Vector3(px, py, pz),
                                rotationAxis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize(),
                                rotationSpeed: Math.random() * 0.2
                            });
                        }
                    }
                }
                
                scene.add(obstacleGroup);
                
                // Store obstacle data for collision detection
                destructibleObstacles.push({
                    group: obstacleGroup,
                    mainBox: box,
                    pieces: pieces,
                    size: size,
                    exploding: false,
                    explosionTime: 0,
                    explosionDuration: 60 // Number of frames for explosion animation
                });
            }
        }
        
        // Make big blocks 75% of the height of the outer boundary (which is 30 units)
        const boundaryHeight = 30;
        const blockHeight = boundaryHeight * 0.75; // 75% of boundary height
        
        // Add 4 large blocks to bounce off of
        const blockPositions = [
            [200, 120], [-200, 150], [180, -220], [-250, -180]
        ];
        
        blockPositions.forEach(pos => {
            const blockSize = 30 + Math.random() * 20;
            
            // Create the big block
            const blockGeometry = new THREE.BoxGeometry(blockSize, blockHeight, blockSize);
            const blockMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff,
                shininess: 80,
                emissive: 0x003333
            });
            const block = new THREE.Mesh(blockGeometry, blockMaterial);
            block.position.set(pos[0], blockHeight/2, pos[1]);
            scene.add(block);
            
            // Add neon trim
            const trimGeometry = new THREE.BoxGeometry(blockSize + 1, 1, blockSize + 1);
            const trimMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const topTrim = new THREE.Mesh(trimGeometry, trimMaterial);
            topTrim.position.y = blockHeight/2 + 0.5;
            block.add(topTrim);
            
            const bottomTrim = new THREE.Mesh(trimGeometry, trimMaterial);
            bottomTrim.position.y = -blockHeight/2 - 0.5;
            block.add(bottomTrim);
            
            // Store big block for collision detection
            bigBlocks.push({
                mesh: block,
                size: blockSize,
                position: new THREE.Vector3(pos[0], blockHeight/2, pos[1])
            });
            
            groundMeshes.push(block);
        });
        
        // Add to scene userData for later reference
        scene.userData.destructibleObstacles = destructibleObstacles;
        scene.userData.bigBlocks = bigBlocks;
    }
    
    function createBoundary() {
        // Create a boundary around the game field (4x bigger)
        const boundarySize = 720; // Slightly smaller than the ground
        const wallHeight = 30;
        const wallThickness = 5;
        
        // Define the boundary material with gradient effect
        const boundaryMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff00ff,
            transparent: true,
            opacity: 0.5,
            emissive: 0x330033,
            shininess: 100
        });
        
        // Create each wall segment
        const walls = [
            // North wall
            { pos: [0, wallHeight/2, -boundarySize/2], size: [boundarySize, wallHeight, wallThickness] },
            // South wall
            { pos: [0, wallHeight/2, boundarySize/2], size: [boundarySize, wallHeight, wallThickness] },
            // East wall
            { pos: [boundarySize/2, wallHeight/2, 0], size: [wallThickness, wallHeight, boundarySize] },
            // West wall
            { pos: [-boundarySize/2, wallHeight/2, 0], size: [wallThickness, wallHeight, boundarySize] }
        ];
        
        // Create all walls
        walls.forEach(wall => {
            const geometry = new THREE.BoxGeometry(wall.size[0], wall.size[1], wall.size[2]);
            const mesh = new THREE.Mesh(geometry, boundaryMaterial);
            mesh.position.set(wall.pos[0], wall.pos[1], wall.pos[2]);
            scene.add(mesh);
            groundMeshes.push(mesh);
            
            // Add glowing edge at the top of each wall
            const edgeGeometry = new THREE.BoxGeometry(wall.size[0] + 0.5, 0.5, wall.size[2] + 0.5);
            const edgeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
            edge.position.set(wall.pos[0], wallHeight, wall.pos[2]);
            scene.add(edge);
        });
        
        // Add stadium stands with audience behind walls
        createStadiumAudience(boundarySize, wallHeight);
    }
    
    function createStadiumAudience(arenaSize, wallHeight) {
        // Stadium configuration
        const standDepth = 70;
        const standHeight = 60;
        const standInset = 20; // Inset from the arena wall
        const sectionWidth = 80;
        const totalSteps = 8; // Number of steps/rows in the stands
        
        // Stadium colors for realistic concrete look
        const concreteColors = [0x888888, 0x777777, 0x999999, 0x666666, 0x777777]; // Different shades of gray
        
        // Create some basic concrete textures
        const concreteTexture = new THREE.DataTexture(
            generateNoiseTexture(64, 64, [180, 180, 180], 20),
            64, 64,
            THREE.RGBAFormat,
            THREE.UnsignedByteType
        );
        concreteTexture.needsUpdate = true;
        
        // Material for stands (concrete look)
        const standMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.9,
            metalness: 0.1,
            map: concreteTexture
        });
        
        // Seat material (plastic)
        const seatColors = [0x1E90FF, 0xFF4500, 0xFFD700, 0x32CD32, 0x9370DB];
        const seatMaterials = seatColors.map(color => new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.7,
            metalness: 0.1,
            emissive: new THREE.Color(color).multiplyScalar(0.1)
        }));
        
        // Create crowd textures with more resolution
        const crowdTexture = new THREE.DataTexture(
            generateCrowdTexture(128, 64),
            128, 64,
            THREE.RGBAFormat,
            THREE.UnsignedByteType
        );
        crowdTexture.needsUpdate = true;
        
        // Crowd material with better appearance
        const crowdMaterial = new THREE.MeshBasicMaterial({
            map: crowdTexture, 
            side: THREE.DoubleSide,
            transparent: true,
            alphaTest: 0.5
        });
        
        // Stadium lighting
        const mainLightColor = 0xFFFFFF;
        const accentLightColors = [0xff0000, 0x00ffff, 0xffff00, 0xff00ff, 0x00ff00];
        
        // Create giant light towers at the corners of the stadium
        const towerPositions = [
            [arenaSize/2 + standInset + 30, arenaSize/2 + standInset + 30],
            [-(arenaSize/2 + standInset + 30), arenaSize/2 + standInset + 30],
            [arenaSize/2 + standInset + 30, -(arenaSize/2 + standInset + 30)],
            [-(arenaSize/2 + standInset + 30), -(arenaSize/2 + standInset + 30)]
        ];
        
        // Create the light towers first
        towerPositions.forEach(pos => {
            createLightTower(pos[0], pos[1], wallHeight + standHeight + 40);
        });
        
        // Create a roof structure with supports
        createStadiumRoof(arenaSize, wallHeight, standHeight, standInset);
        
        // Create stands on all four sides
        for (let side = 0; side < 4; side++) {
            // Determine stand position based on side
            let standX = 0, standZ = 0, rotationY = 0;
            const sidePos = (arenaSize / 2) + standInset;
            
            if (side === 0) { // North
                standZ = -sidePos;
                rotationY = 0;
            } else if (side === 1) { // East
                standX = sidePos;
                rotationY = Math.PI / 2;
            } else if (side === 2) { // South
                standZ = sidePos;
                rotationY = Math.PI;
            } else { // West
                standX = -sidePos;
                rotationY = -Math.PI / 2;
            }
            
            // Create sections along each side
            for (let section = -4; section <= 4; section++) {
                // Position along the side
                let sectionOffsetX = 0, sectionOffsetZ = 0;
                
                if (side === 0 || side === 2) {
                    sectionOffsetX = section * sectionWidth;
                } else {
                    sectionOffsetZ = section * sectionWidth;
                }
                
                // Concrete base for this section (structural foundation)
                const baseGeometry = new THREE.BoxGeometry(
                    side % 2 === 0 ? sectionWidth : standDepth,
                    wallHeight * 0.5,
                    side % 2 === 0 ? standDepth : sectionWidth
                );
                
                const baseMaterial = new THREE.MeshStandardMaterial({
                    color: 0x555555,
                    roughness: 1.0,
                    map: concreteTexture
                });
                
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.set(
                    standX + sectionOffsetX, 
                    wallHeight * 0.25, 
                    standZ + sectionOffsetZ
                );
                base.rotation.y = rotationY;
                scene.add(base);
                
                // Create tiered stands with individual steps/rows
                const stepDepth = standDepth / totalSteps;
                const stepWidth = side % 2 === 0 ? sectionWidth : sectionWidth * 0.95;
                const stepHeight = standHeight / totalSteps;
                
                // Create each step
                for (let step = 0; step < totalSteps; step++) {
                    // Position for this step
                    const stepY = wallHeight + step * stepHeight;
                    
                    // Calculate step position with increasing set back
                    let stepOffsetZ = 0;
                    let stepOffsetX = 0;
                    
                    if (side === 0) {
                        stepOffsetZ = step * stepDepth - standDepth/2 + stepDepth/2;
                    } else if (side === 1) {
                        stepOffsetX = -(step * stepDepth - standDepth/2 + stepDepth/2);
                    } else if (side === 2) {
                        stepOffsetZ = -(step * stepDepth - standDepth/2 + stepDepth/2);
                    } else {
                        stepOffsetX = step * stepDepth - standDepth/2 + stepDepth/2;
                    }
                    
                    // Create step geometry
                    const stepGeometry = new THREE.BoxGeometry(
                        side % 2 === 0 ? stepWidth : stepDepth,
                        stepHeight,
                        side % 2 === 0 ? stepDepth : stepWidth
                    );
                    
                    // Slightly vary concrete color for each step
                    const thisStepMaterial = standMaterial.clone();
                    thisStepMaterial.color.set(concreteColors[step % concreteColors.length]);
                    
                    const thisStep = new THREE.Mesh(stepGeometry, thisStepMaterial);
                    thisStep.position.set(
                        standX + sectionOffsetX + stepOffsetX,
                        stepY + stepHeight/2,
                        standZ + sectionOffsetZ + stepOffsetZ
                    );
                    thisStep.rotation.y = rotationY;
                    scene.add(thisStep);
                    
                    // Add colored seats on the steps (except first step which is a walkway)
                    if (step > 0) {
                        // Seats are small blocks lined along the step
                        const seatsPerRow = Math.floor(stepWidth / 3);
                        const seatMaterial = seatMaterials[section % seatMaterials.length];
                        
                        for (let s = 0; s < seatsPerRow; s++) {
                            // Only place seats on every other position (with gaps)
                            if (Math.random() < 0.85) {
                                let seatX = 0, seatZ = 0;
                                
                                // Calculate seat position along the step
                                if (side % 2 === 0) {
                                    seatX = -stepWidth/2 + s * (stepWidth / seatsPerRow) + (stepWidth / seatsPerRow) / 2;
                                    seatZ = -stepDepth * 0.3; // Place seat toward the front of the step
                                } else {
                                    seatX = -stepDepth * 0.3; // Place seat toward the front of the step
                                    seatZ = -stepWidth/2 + s * (stepWidth / seatsPerRow) + (stepWidth / seatsPerRow) / 2;
                                }
                                
                                const seatGeometry = new THREE.BoxGeometry(1.5, 0.5, 1.5);
                                const seat = new THREE.Mesh(
                                    seatGeometry,
                                    seatMaterial
                                );
                                
                                // Position seat relative to its step
                                seat.position.set(seatX, stepHeight/2 + 0.3, seatZ);
                                thisStep.add(seat);
                            }
                        }
                    }
                    
                    // Add spectators as billboards on steps 2 and up
                    if (step > 1) {
                        // Create spectator group for this row
                        const crowdGroup = new THREE.Group();
                        const spectatorHeight = 3.5;
                        
                        // Create a row of spectators as planes
                        const spectatorPlane = new THREE.PlaneGeometry(stepWidth * 0.95, spectatorHeight);
                        const spectators = new THREE.Mesh(spectatorPlane, crowdMaterial);
                        
                        // Position just above the seats
                        let spectatorX = 0, spectatorZ = 0;
                        
                        if (side % 2 === 0) {
                            spectatorZ = -stepDepth * 0.3;
                        } else {
                            spectatorX = -stepDepth * 0.3;
                        }
                        
                        spectators.position.set(
                            spectatorX,
                            stepHeight/2 + spectatorHeight/2,
                            spectatorZ
                        );
                        
                        // Rotate to face the center of the arena
                        spectators.rotation.y = side % 2 === 0 ? Math.PI : Math.PI/2;
                        
                        crowdGroup.add(spectators);
                        thisStep.add(crowdGroup);
                        
                        // Add random animation to crowd sections
                        animateCrowdSection(crowdGroup, Math.random() < 0.3);
                    }
                }
                
                // Add structural supports/columns
                addStructuralSupports(standX + sectionOffsetX, standZ + sectionOffsetZ, standHeight, wallHeight, standDepth, side, rotationY);
                
                // Add handrails along steps
                addHandrails(standX + sectionOffsetX, standZ + sectionOffsetZ, standHeight, wallHeight, totalSteps, stepHeight, stepDepth, side, rotationY, stepWidth);
                
                // Add stadium architecture elements - entrances, banners, etc.
                if (Math.random() < 0.7 && section % 2 === 0) {
                    addStadiumDetails(standX + sectionOffsetX, standZ + sectionOffsetZ, side, rotationY, wallHeight);
                }
                
                // Add section lighting
                addSectionLighting(standX + sectionOffsetX, standZ + sectionOffsetZ, standHeight, wallHeight, side, rotationY);
            }
        }
        
        // Add animated crowd functions
        setInterval(updateCrowdTexture, 500, crowdTexture);
        
        // Add ambient environmental lighting
        const ambientLight = new THREE.AmbientLight(0xCCCCFF, 0.3);
        scene.add(ambientLight);
        
        // Add global stadium lights
        const mainLight1 = new THREE.DirectionalLight(0xFFFFFF, 0.8);
        mainLight1.position.set(arenaSize/2, standHeight * 4, arenaSize/2);
        mainLight1.target.position.set(0, 0, 0);
        scene.add(mainLight1);
        scene.add(mainLight1.target);
        
        const mainLight2 = new THREE.DirectionalLight(0xFFFFFF, 0.6);
        mainLight2.position.set(-arenaSize/2, standHeight * 3, -arenaSize/2);
        mainLight2.target.position.set(0, 0, 0);
        scene.add(mainLight2);
        scene.add(mainLight2.target);
    }
    
    function createLightTower(x, z, height) {
        // Create a tower structure with lights at the top
        const towerBaseWidth = 10;
        const towerBaseGeometry = new THREE.BoxGeometry(towerBaseWidth, 20, towerBaseWidth);
        const towerBaseMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.8
        });
        
        const towerBase = new THREE.Mesh(towerBaseGeometry, towerBaseMaterial);
        towerBase.position.set(x, 10, z);
        scene.add(towerBase);
        
        // Create the tower shaft
        const towerShaftGeometry = new THREE.BoxGeometry(towerBaseWidth * 0.6, height - 20, towerBaseWidth * 0.6);
        const towerShaft = new THREE.Mesh(towerShaftGeometry, towerBaseMaterial);
        towerShaft.position.set(x, height/2, z);
        scene.add(towerShaft);
        
        // Create light bank at the top
        const lightBankGeometry = new THREE.BoxGeometry(towerBaseWidth * 3, 15, towerBaseWidth * 3);
        const lightBankMaterial = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.5,
            metalness: 0.8
        });
        
        const lightBank = new THREE.Mesh(lightBankGeometry, lightBankMaterial);
        lightBank.position.set(x, height, z);
        scene.add(lightBank);
        
        // Add multiple powerful spotlights pointing at the arena
        const spotlightColors = [0xFFFFFF, 0xFFFFF0];
        
        for (let i = 0; i < 6; i++) {
            const angle = (i / 6) * Math.PI * 2;
            const radius = towerBaseWidth * 1.2;
            
            const lightX = Math.cos(angle) * radius;
            const lightZ = Math.sin(angle) * radius;
            
            const spotlight = new THREE.SpotLight(
                spotlightColors[i % spotlightColors.length],
                2,
                1000,
                Math.PI / 8,
                0.5,
                1
            );
            
            spotlight.position.set(x + lightX, height, z + lightZ);
            spotlight.target.position.set(0, 0, 0); // Point at arena center
            
            // Add slight random offset
            spotlight.target.position.x += (Math.random() - 0.5) * 100;
            spotlight.target.position.z += (Math.random() - 0.5) * 100;
            
            scene.add(spotlight);
            scene.add(spotlight.target);
            
            // Add lens flare effect for the spotlight
            const spotlightGeometry = new THREE.SphereGeometry(3, 8, 8);
            const spotlightMaterial = new THREE.MeshBasicMaterial({
                color: spotlightColors[i % spotlightColors.length],
                emissive: spotlightColors[i % spotlightColors.length]
            });
            
            const spotlightMesh = new THREE.Mesh(spotlightGeometry, spotlightMaterial);
            spotlightMesh.position.set(x + lightX, height, z + lightZ);
            scene.add(spotlightMesh);
            
            // Randomly make some lights flash
            if (Math.random() < 0.3) {
                animateStadiumLight(spotlight, spotlightMesh);
            }
        }
    }
    
    function createStadiumRoof(arenaSize, wallHeight, standHeight, standInset) {
        // Create partial roof coverage on parts of the stadium
        const roofHeight = wallHeight + standHeight + 10;
        const roofInset = 30; // How far the roof extends into the arena
        const roofThickness = 5;
        
        // We'll create roof sections over two opposite sides
        const sides = [0, 2]; // North and South sides
        
        sides.forEach(side => {
            let roofX = 0, roofZ = 0, rotationY = 0;
            const sidePos = (arenaSize / 2) + standInset;
            
            if (side === 0) { // North
                roofZ = -sidePos + roofInset;
                rotationY = 0;
            } else if (side === 2) { // South
                roofZ = sidePos - roofInset;
                rotationY = Math.PI;
            }
            
            // Create the main roof structure
            const roofWidth = arenaSize * 0.8;
            const roofDepth = 80;
            
            const roofGeometry = new THREE.BoxGeometry(roofWidth, roofThickness, roofDepth);
            const roofMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.7,
                metalness: 0.3
            });
            
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(roofX, roofHeight, roofZ);
            roof.rotation.y = rotationY;
            scene.add(roof);
            
            // Create support structures for the roof
            const numSupports = 6;
            const supportSpacing = roofWidth / (numSupports - 1);
            
            for (let i = 0; i < numSupports; i++) {
                const supportX = roofX - roofWidth/2 + i * supportSpacing;
                
                // Create architectural support column
                const supportGeometry = new THREE.CylinderGeometry(5, 5, roofHeight - wallHeight, 8);
                const supportMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    roughness: 0.5,
                    metalness: 0.5
                });
                
                const support = new THREE.Mesh(supportGeometry, supportMaterial);
                
                if (side === 0) {
                    support.position.set(supportX, (roofHeight + wallHeight) / 2, roofZ - roofDepth/2);
                } else {
                    support.position.set(supportX, (roofHeight + wallHeight) / 2, roofZ + roofDepth/2);
                }
                
                scene.add(support);
                
                // Create truss support from column to roof
                createTrussSupport(supportX, roofHeight - 20, roofZ, roofDepth, side);
            }
            
            // Add architectural details to the roof
            addRoofDetails(roofX, roofHeight, roofZ, roofWidth, roofDepth, side, rotationY);
        });
    }
    
    function createTrussSupport(x, y, z, depth, side) {
        // Create a triangular truss connecting to the roof
        const trussColor = 0x888888;
        const trussMaterial = new THREE.MeshStandardMaterial({
            color: trussColor,
            roughness: 0.5,
            metalness: 0.7
        });
        
        // Create truss beams
        const beamGeometry = new THREE.CylinderGeometry(1, 1, 40, 6);
        
        // Position depends on which side we're on
        let trussZ = side === 0 ? z - depth/2 + 20 : z + depth/2 - 20;
        
        // Main diagonal beam
        const beam1 = new THREE.Mesh(beamGeometry, trussMaterial);
        beam1.position.set(x, y - 10, trussZ);
        beam1.rotation.x = Math.PI / 4; // 45 degree angle
        if (side === 2) beam1.rotation.x = -Math.PI / 4;
        scene.add(beam1);
        
        // Horizontal beam
        const beam2 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 30, 6), trussMaterial);
        beam2.position.set(x, y, trussZ + (side === 0 ? 10 : -10));
        beam2.rotation.z = Math.PI / 2; // Make horizontal
        scene.add(beam2);
        
        // Add vertical support
        const beam3 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 15, 6), trussMaterial);
        beam3.position.set(x, y - 7.5, trussZ + (side === 0 ? 15 : -15));
        scene.add(beam3);
    }
    
    function addRoofDetails(x, y, z, width, depth, side, rotationY) {
        // Add banners hanging from the roof
        const bannerColors = [0xFF0000, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF];
        
        for (let i = 0; i < 7; i++) {
            const bannerX = x - width/2 + (i + 0.5) * (width / 7);
            
            // Banner geometry
            const bannerWidth = width / 10;
            const bannerHeight = 20;
            
            const bannerGeometry = new THREE.PlaneGeometry(bannerWidth, bannerHeight);
            const bannerMaterial = new THREE.MeshBasicMaterial({
                color: bannerColors[i % bannerColors.length],
                side: THREE.DoubleSide
            });
            
            const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);
            
            // Position banner
            let bannerZ = side === 0 ? z + depth/4 : z - depth/4;
            banner.position.set(bannerX, y - bannerHeight/2 - 2, bannerZ);
            
            // Rotate banner
            banner.rotation.y = rotationY;
            
            scene.add(banner);
            
            // Add subtle animation to banner
            animateBanner(banner);
        }
        
        // Add lights along the roof edge
        const numLights = 10;
        const lightSpacing = width / numLights;
        
        for (let i = 0; i < numLights; i++) {
            const lightX = x - width/2 + (i + 0.5) * lightSpacing;
            const lightZ = side === 0 ? z + depth/2 - 5 : z - depth/2 + 5;
            
            const light = new THREE.PointLight(0xFFFFFF, 0.5, 50);
            light.position.set(lightX, y - 5, lightZ);
            scene.add(light);
            
            // Add light fixture
            const fixtureGeometry = new THREE.CylinderGeometry(1.5, 1.5, 3, 8);
            const fixtureMaterial = new THREE.MeshStandardMaterial({
                color: 0xDDDDDD,
                emissive: 0xCCCCCC,
                emissiveIntensity: 0.5
            });
            
            const fixture = new THREE.Mesh(fixtureGeometry, fixtureMaterial);
            fixture.position.copy(light.position);
            fixture.rotation.x = Math.PI / 2;
            scene.add(fixture);
        }
    }
    
    function addStructuralSupports(x, z, standHeight, wallHeight, standDepth, side, rotationY) {
        // Add structural columns
        const columnRadius = 2;
        const columnHeight = wallHeight + standHeight * 0.8;
        const columnGeometry = new THREE.CylinderGeometry(columnRadius, columnRadius, columnHeight, 8);
        const columnMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.7,
            metalness: 0.2
        });
        
        // Position columns at the corners
        const positions = [
            [15, -standDepth/2 + columnRadius/2],
            [-15, -standDepth/2 + columnRadius/2],
            [15, standDepth/2 - columnRadius/2],
            [-15, standDepth/2 - columnRadius/2]
        ];
        
        positions.forEach(pos => {
            let colX = 0, colZ = 0;
            
            if (side % 2 === 0) {
                colX = x + pos[0];
                colZ = z + pos[1];
            } else {
                colX = x + pos[1];
                colZ = z + pos[0];
            }
            
            const column = new THREE.Mesh(columnGeometry, columnMaterial);
            column.position.set(colX, columnHeight/2, colZ);
            scene.add(column);
            
            // Add column base
            const baseGeometry = new THREE.BoxGeometry(columnRadius * 2 + 1, columnRadius, columnRadius * 2 + 1);
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x666666,
                roughness: 0.9
            });
            
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(colX, columnRadius/2, colZ);
            scene.add(base);
        });
    }
    
    function addHandrails(x, z, standHeight, wallHeight, totalSteps, stepHeight, stepDepth, side, rotationY, stepWidth) {
        // Add handrails on the steps
        const railColor = 0xCCCCCC;
        const railMaterial = new THREE.MeshStandardMaterial({
            color: railColor,
            roughness: 0.5,
            metalness: 0.7
        });
        
        // Add two sets of railings - one on each end
        for (let railSide = -1; railSide <= 1; railSide += 2) {
            // Skip some railings randomly
            if (Math.random() < 0.3) continue;
            
            let railX = side % 2 === 0 ? x + railSide * stepWidth/2 : x;
            let railZ = side % 2 === 0 ? z : z + railSide * stepWidth/2;
            
            // Create vertical posts
            for (let step = 0; step < totalSteps; step++) {
                const railHeight = 5;
                const postGeometry = new THREE.CylinderGeometry(0.3, 0.3, railHeight, 6);
                
                // Calculate position for each step
                let postX = railX;
                let postZ = railZ;
                
                // Offset for the step progression
                if (side === 0) {
                    postZ += step * stepDepth - standHeight/2 + stepDepth/2;
                } else if (side === 1) {
                    postX += -(step * stepDepth - standHeight/2 + stepDepth/2);
                } else if (side === 2) {
                    postZ += -(step * stepDepth - standHeight/2 + stepDepth/2);
                } else {
                    postX += step * stepDepth - standHeight/2 + stepDepth/2;
                }
                
                const post = new THREE.Mesh(postGeometry, railMaterial);
                post.position.set(
                    postX,
                    wallHeight + step * stepHeight + railHeight/2,
                    postZ
                );
                scene.add(post);
                
                // Add horizontal railings connecting posts
                if (step < totalSteps - 1) {
                    const railLength = Math.sqrt(stepDepth * stepDepth + stepHeight * stepHeight);
                    const railGeometry = new THREE.CylinderGeometry(0.2, 0.2, railLength, 6);
                    
                    const rail = new THREE.Mesh(railGeometry, railMaterial);
                    
                    // Position halfway between current post and next post
                    let nextPostX = postX;
                    let nextPostZ = postZ;
                    
                    if (side === 0) {
                        nextPostZ += stepDepth;
                    } else if (side === 1) {
                        nextPostX -= stepDepth;
                    } else if (side === 2) {
                        nextPostZ -= stepDepth;
                    } else {
                        nextPostX += stepDepth;
                    }
                    
                    // Position the rail
                    rail.position.set(
                        (postX + nextPostX) / 2,
                        wallHeight + step * stepHeight + railHeight - 0.5,
                        (postZ + nextPostZ) / 2
                    );
                    
                    // Rotate the rail according to the step slope
                    const angle = Math.atan2(stepHeight, stepDepth);
                    
                    if (side === 0) {
                        rail.rotation.x = Math.PI/2 - angle;
                        rail.rotation.z = Math.PI/2;
                    } else if (side === 1) {
                        rail.rotation.x = Math.PI/2;
                        rail.rotation.z = Math.PI/2 - angle;
                    } else if (side === 2) {
                        rail.rotation.x = Math.PI/2 + angle;
                        rail.rotation.z = Math.PI/2;
                    } else {
                        rail.rotation.x = Math.PI/2;
                        rail.rotation.z = Math.PI/2 + angle;
                    }
                    
                    scene.add(rail);
                }
            }
        }
    }
    
    function addStadiumDetails(x, z, side, rotationY, wallHeight) {
        // Add entrance tunnels
        const tunnelWidth = 8;
        const tunnelHeight = 8;
        const tunnelDepth = 15;
        
        const tunnelGeometry = new THREE.BoxGeometry(tunnelWidth, tunnelHeight, tunnelDepth);
        const tunnelMaterial = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 1.0,
            metalness: 0.0
        });
        
        // Calculate tunnel position
        let tunnelX = x;
        let tunnelZ = z;
        
        if (side === 0) { // North
            tunnelZ -= 20;
        } else if (side === 1) { // East
            tunnelX += 20;
        } else if (side === 2) { // South
            tunnelZ += 20;
        } else { // West
            tunnelX -= 20;
        }
        
        const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
        tunnel.position.set(tunnelX, wallHeight/2, tunnelZ);
        tunnel.rotation.y = rotationY;
        scene.add(tunnel);
        
        // Add tunnel light
        const tunnelLight = new THREE.PointLight(0xFFCC88, 0.8, 20);
        tunnelLight.position.set(tunnelX, wallHeight/2, tunnelZ);
        scene.add(tunnelLight);
        
        // Random decorative elements
        if (Math.random() < 0.5) {
            // Add banners or signs 
            const signColors = [0xFF0000, 0xFFFF00, 0x00FF00];
            const signGeometry = new THREE.PlaneGeometry(10, 5);
            const signMaterial = new THREE.MeshBasicMaterial({ 
                color: signColors[Math.floor(Math.random() * signColors.length)],
                side: THREE.DoubleSide
            });
            
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            
            // Position the sign above the tunnel
            sign.position.set(tunnelX, wallHeight + 5, tunnelZ);
            sign.rotation.y = rotationY;
            
            scene.add(sign);
        }
    }
    
    function addSectionLighting(x, z, standHeight, wallHeight, side, rotationY) {
        // Add spotlights to illuminate each section
        const lightColor = 0xFFFFFF;
        
        // Calculate spotlight position
        let spotX = x;
        let spotZ = z;
        let targetX = x;
        let targetZ = z;
        
        // Position depends on which side we're on
        if (side === 0) {
            spotZ -= 40;
            targetZ += 20;
        } else if (side === 1) {
            spotX += 40;
            targetX -= 20;
        } else if (side === 2) {
            spotZ += 40;
            targetZ -= 20;
        } else {
            spotX -= 40;
            targetX += 20;
        }
        
        // Create a spotlight pointing at the section
        const spotlight = new THREE.SpotLight(
            lightColor,
            0.8,
            200,
            Math.PI / 6,
            0.5,
            1
        );
        
        spotlight.position.set(spotX, wallHeight + standHeight + 10, spotZ);
        spotlight.target.position.set(targetX, wallHeight, targetZ);
        
        scene.add(spotlight);
        scene.add(spotlight.target);
        
        // Add light fixture
        const fixtureGeometry = new THREE.CylinderGeometry(2, 3, 4, 8);
        const fixtureMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            metalness: 0.8,
            roughness: 0.2
        });
        
        const fixture = new THREE.Mesh(fixtureGeometry, fixtureMaterial);
        fixture.position.copy(spotlight.position);
        
        // Rotate fixture to point at target
        const dx = targetX - spotX;
        const dy = wallHeight - (wallHeight + standHeight + 10);
        const dz = targetZ - spotZ;
        
        fixture.lookAt(new THREE.Vector3(targetX, wallHeight, targetZ));
        
        scene.add(fixture);
    }
    
    function animateCrowdSection(crowdGroup, isExcited) {
        // Define animation properties
        const animSpeed = isExcited ? 0.05 : 0.02;
        const animRange = isExcited ? 0.2 : 0.1;
        
        // Animation parameters 
        crowdGroup.userData = {
            baseY: crowdGroup.position.y,
            time: Math.random() * Math.PI * 2, // Random starting phase
            isExcited: isExcited,
            excitementTime: 0,
            animSpeed: animSpeed,
            animRange: animRange
        };
        
        // Add animation function to be called each frame
        scene.userData.crowdGroups = scene.userData.crowdGroups || [];
        scene.userData.crowdGroups.push(crowdGroup);
    }
    
    // This function will be called in the main animation loop
    function updateCrowds() {
        if (scene.userData.crowdGroups) {
            scene.userData.crowdGroups.forEach(crowdGroup => {
                if (crowdGroup.userData) {
                    // Update time parameter
                    crowdGroup.userData.time += crowdGroup.userData.animSpeed;
                    
                    // Simple sine wave animation for bobbing up and down
                    const newY = crowdGroup.userData.baseY + 
                                Math.sin(crowdGroup.userData.time) * crowdGroup.userData.animRange;
                    
                    crowdGroup.position.y = newY;
                    
                    // Occasionally make the crowd excited
                    if (Math.random() < 0.001) {
                        crowdGroup.userData.isExcited = true;
                        crowdGroup.userData.excitementTime = 100; // Duration of excitement
                        crowdGroup.userData.animSpeed = 0.1;
                        crowdGroup.userData.animRange = 0.3;
                    }
                    
                    // Return to normal after excitement
                    if (crowdGroup.userData.isExcited) {
                        crowdGroup.userData.excitementTime--;
                        
                        if (crowdGroup.userData.excitementTime <= 0) {
                            crowdGroup.userData.isExcited = false;
                            crowdGroup.userData.animSpeed = 0.02;
                            crowdGroup.userData.animRange = 0.1;
                        }
                    }
                }
            });
        }
    }
    
    function animateBanner(banner) {
        // Add animation parameters
        banner.userData = {
            time: Math.random() * Math.PI * 2,
            waveSpeed: 0.02 + Math.random() * 0.02,
            waveAmplitude: 0.05 + Math.random() * 0.05
        };
        
        // Add to animation list
        scene.userData.banners = scene.userData.banners || [];
        scene.userData.banners.push(banner);
    }
    
    // Update banners in animation loop
    function updateBanners() {
        if (scene.userData.banners) {
            scene.userData.banners.forEach(banner => {
                if (banner.userData) {
                    banner.userData.time += banner.userData.waveSpeed;
                    
                    // Wave effect
                    banner.rotation.z = Math.sin(banner.userData.time) * banner.userData.waveAmplitude;
                }
            });
        }
    }
    
    function generateNoiseTexture(width, height, baseColor, variance) {
        const data = new Uint8Array(width * height * 4);
        
        for (let i = 0; i < width * height; i++) {
            const r = baseColor[0] + Math.floor((Math.random() - 0.5) * variance);
            const g = baseColor[1] + Math.floor((Math.random() - 0.5) * variance);
            const b = baseColor[2] + Math.floor((Math.random() - 0.5) * variance);
            
            data[i * 4] = Math.max(0, Math.min(255, r));
            data[i * 4 + 1] = Math.max(0, Math.min(255, g));
            data[i * 4 + 2] = Math.max(0, Math.min(255, b));
            data[i * 4 + 3] = 255;
        }
        
        return data;
    }
    
    function generateCrowdTexture(width, height) {
        // Create data for texture (R, G, B, A format)
        const data = new Uint8Array(width * height * 4);
        
        // Define skin tone colors
        const skinTones = [
            [235, 192, 178], // Light
            [223, 172, 148], // Medium light
            [193, 132, 108], // Medium
            [143, 90, 63],   // Medium dark
            [94, 52, 26]     // Dark
        ];
        
        // Define clothing colors
        const clothingColors = [
            [255, 0, 0],     // Red
            [0, 0, 255],     // Blue
            [0, 255, 0],     // Green
            [255, 255, 0],   // Yellow
            [255, 0, 255],   // Magenta
            [0, 255, 255],   // Cyan
            [255, 165, 0],   // Orange
            [128, 0, 128],   // Purple
            [0, 128, 0],     // Dark green
            [0, 0, 0],       // Black
            [255, 255, 255], // White
            [139, 69, 19]    // Brown
        ];
        
        // Create a more structured crowd texture
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                
                // Determine if this pixel is a "person"
                const isPerson = Math.random() < 0.7;
                
                if (isPerson) {
                    // Decide if this is a head or body
                    const isHead = y < height * 0.35; // Top 35% for heads
                    
                    if (isHead) {
                        // Use a skin tone
                        const skin = skinTones[Math.floor(Math.random() * skinTones.length)];
                        data[i] = skin[0];     // R
                        data[i + 1] = skin[1]; // G
                        data[i + 2] = skin[2]; // B
                    } else {
                        // Use a clothing color
                        const clothing = clothingColors[Math.floor(Math.random() * clothingColors.length)];
                        data[i] = clothing[0];     // R
                        data[i + 1] = clothing[1]; // G
                        data[i + 2] = clothing[2]; // B
                    }
                    
                    data[i + 3] = 255; // A (opaque)
                } else {
                    // Empty space (transparent)
                    data[i + 3] = 0; // A (transparent)
                }
                
                // Add some noise
                if (data[i + 3] > 0) {
                    const noise = (Math.random() - 0.5) * 30;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
                }
            }
        }
        
        return data;
    }
    
    function updateCrowdTexture(texture) {
        // Update about 5% of the pixels to simulate movement
        const data = texture.image.data;
        const width = texture.image.width;
        const height = texture.image.height;
        
        // Define the same color palettes as in generateCrowdTexture
        const skinTones = [
            [235, 192, 178], [223, 172, 148], [193, 132, 108], 
            [143, 90, 63], [94, 52, 26]
        ];
        
        const clothingColors = [
            [255, 0, 0], [0, 0, 255], [0, 255, 0], [255, 255, 0],
            [255, 0, 255], [0, 255, 255], [255, 165, 0], [128, 0, 128],
            [0, 128, 0], [0, 0, 0], [255, 255, 255], [139, 69, 19]
        ];
        
        // Only update pixels that are already opaque
        for (let i = 0; i < width * height * 0.05; i++) {
            const pixelIndex = Math.floor(Math.random() * width * height);
            const dataIndex = pixelIndex * 4;
            
            // Only update if the pixel is opaque
            if (data[dataIndex + 3] > 0) {
                // If it's in the head area
                if (Math.floor(pixelIndex / width) < height * 0.35) {
                    const skin = skinTones[Math.floor(Math.random() * skinTones.length)];
                    data[dataIndex] = skin[0];
                    data[dataIndex + 1] = skin[1];
                    data[dataIndex + 2] = skin[2];
                } else {
                    // In the body area
                    const clothing = clothingColors[Math.floor(Math.random() * clothingColors.length)];
                    data[dataIndex] = clothing[0];
                    data[dataIndex + 1] = clothing[1];
                    data[dataIndex + 2] = clothing[2];
                }
                
                // Add some noise for variation
                const noise = (Math.random() - 0.5) * 30;
                data[dataIndex] = Math.max(0, Math.min(255, data[dataIndex] + noise));
                data[dataIndex + 1] = Math.max(0, Math.min(255, data[dataIndex + 1] + noise));
                data[dataIndex + 2] = Math.max(0, Math.min(255, data[dataIndex + 2] + noise));
            }
        }
        
        texture.needsUpdate = true;
    }
    
    function animateStadiumLight(light, lightMesh) {
        // Random interval for flashing
        const duration = 1000 + Math.random() * 3000;
        
        // Flash the light
        const flashLight = () => {
            // Turn down
            light.intensity = 0.3;
            if (lightMesh) lightMesh.scale.set(0.6, 0.6, 0.6);
            
            // Wait, then turn on
            setTimeout(() => {
                light.intensity = 1 + Math.random() * 2;
                if (lightMesh) lightMesh.scale.set(1, 1, 1);
                
                // Schedule next flash
                setTimeout(flashLight, duration);
            }, 100 + Math.random() * 200);
        };
        
        // Start the animation cycle
        setTimeout(flashLight, Math.random() * duration);
    }
    
    function createTruck() {
        // Create a better-looking truck, but still with NO ROTATION
        truck = new THREE.Group();
        
        // Chassis with improved visuals
        const chassisGeometry = new THREE.BoxGeometry(4.5, 1, 8);
        const chassisMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff00ff,
            shininess: 80,
            specular: 0xffffff
        });
        const chassis = new THREE.Mesh(chassisGeometry, chassisMaterial);
        chassis.position.y = 0.5;
        truck.add(chassis);
        
        // Add neon trim to chassis
        const trimGeometry = new THREE.BoxGeometry(4.6, 0.1, 8.1);
        const trimMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const trim = new THREE.Mesh(trimGeometry, trimMaterial);
        trim.position.y = 1.05;
        truck.add(trim);
        
        // Cab with better detailing
        const cabGeometry = new THREE.BoxGeometry(4, 1.5, 3);
        const cabMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff00ff,
            shininess: 90,
            specular: 0xffffff
        });
        const cab = new THREE.Mesh(cabGeometry, cabMaterial);
        cab.position.set(0, 1.5, -2);
        truck.add(cab);
        
        // Windshield
        const windshieldGeometry = new THREE.PlaneGeometry(3.5, 1.2);
        const windshieldMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const windshield = new THREE.Mesh(windshieldGeometry, windshieldMaterial);
        windshield.position.set(0, 1.8, -3.2);
        windshield.rotation.x = 0.3;
        truck.add(windshield);
        
        // Add headlights
        const headlightGeometry = new THREE.SphereGeometry(0.4, 16, 16);
        const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        // Left headlight
        const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
        leftHeadlight.position.set(-1.5, 0.8, -4);
        truck.add(leftHeadlight);
        
        // Right headlight
        const rightHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
        rightHeadlight.position.set(1.5, 0.8, -4);
        truck.add(rightHeadlight);
        
        // Create spinning wheels that can animate
        const wheelRadius = 1.4;
        const wheelWidth = 1.0;
        const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth, 24);
        const wheelMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x333333,
            shininess: 30
        });
        
        // Wheel hub material
        const hubGeometry = new THREE.CylinderGeometry(wheelRadius * 0.5, wheelRadius * 0.5, wheelWidth + 0.1, 16);
        const hubMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xdddddd,
            shininess: 100,
            specular: 0xffffff
        });
        
        // Store wheel references
        truck.userData.wheels = [];
        
        const wheelPositions = [
            {x: -2.2, y: wheelRadius, z: -3, steering: true}, // Front left
            {x: 2.2, y: wheelRadius, z: -3, steering: true},  // Front right
            {x: -2.2, y: wheelRadius, z: 3, steering: false}, // Rear left
            {x: 2.2, y: wheelRadius, z: 3, steering: false}   // Rear right
        ];
        
        wheelPositions.forEach(pos => {
            // Create wheel group
            const wheelGroup = new THREE.Group();
            wheelGroup.position.set(pos.x, pos.y, pos.z);
            
            // Create wheel mesh
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.rotation.z = Math.PI / 2; // Correct wheel orientation
            wheelGroup.add(wheel);
            
            // Add hub cap
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            hub.rotation.z = Math.PI / 2;
            wheelGroup.add(hub);
            
            // Add wheel group to truck
            truck.add(wheelGroup);
            
            // Store wheel reference
            truck.userData.wheels.push({
                group: wheelGroup,
                mesh: wheel,
                steering: pos.steering,
                rotation: 0
            });
        });
        
        // Add fancy neon underglow
        const glowGeometry = new THREE.PlaneGeometry(6, 10);
        const glowMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.rotation.x = Math.PI / 2;
        glow.position.y = -0.5;
        truck.add(glow);
        
        // Set initial position
        truck.position.set(0, 2, 0);
        
        // Make sure there's absolutely no rotation initially
        truck.rotation.set(0, 0, 0);
        
        // Add to scene
        scene.add(truck);
        
        // Add properties for movement
        truck.userData = {
            speed: 0,
            direction: 0, // Direction in radians
            height: 2,    // Height above ground
            onGround: true,
            wasOnRamp: false,
            wheels: truck.userData.wheels
        };
    }
    
    function onKeyDown(event) {
        keys[event.key.toLowerCase()] = true;
    }
    
    function onKeyUp(event) {
        keys[event.key.toLowerCase()] = false;
    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function updateTruck() {
        // Enhanced driving constants for better feel
        const ACCELERATION = 0.08;       // Smoother acceleration
        const MAX_SPEED = 2.0;           // Higher top speed
        const MAX_REVERSE_SPEED = 1.0;   // Decent reverse speed
        const STEERING_SPEED = 0.06;     // 50% tighter turning radius (was 0.04)
        const DRIFT_FACTOR = 0.92;       // Slight drift effect
        
        // Dynamic handling variables
        const speed = truck.userData.speed || 0;
        const speedPercent = Math.min(1, Math.abs(speed) / MAX_SPEED);
        
        // Get current direction and store old direction for drift calculations
        const oldDirection = truck.userData.direction || 0;
        let newDirection = oldDirection;
        
        // Changed controls: left/right arrows steer, up/down drive forward/backward
        // Steer only when moving or very slightly when stationary
        if (Math.abs(speed) > 0.1) {
            // Normal steering when moving
            const adaptiveSteering = STEERING_SPEED * (1 - speedPercent * 0.5);
            
            if (keys['arrowleft']) {
                newDirection += adaptiveSteering; // Turn left
            }
            if (keys['arrowright']) {
                newDirection -= adaptiveSteering; // Turn right
            }
        } else {
            // Very subtle steering when stationary
            if (keys['arrowleft']) {
                newDirection += STEERING_SPEED * 0.2; 
            }
            if (keys['arrowright']) {
                newDirection -= STEERING_SPEED * 0.2;
            }
        }
        
        // Add momentum to steering for smoother direction changes
        truck.userData.direction = oldDirection * 0.1 + newDirection * 0.9;
        
        // Actually ROTATE the truck model to match its direction
        truck.rotation.y = truck.userData.direction;
        
        // Calculate movement vectors - always relative to truck's current rotation
        // Forward is always the direction the truck is facing
        const dirX = Math.sin(truck.userData.direction);
        const dirZ = Math.cos(truck.userData.direction);
        
        // Enhanced acceleration with better responsiveness
        if (keys['arrowup']) {
            // Progressive acceleration - slower at start, quicker in the middle range
            const accelFactor = 1 - (Math.pow(speed / MAX_SPEED, 2) * 0.8);
            truck.userData.speed = Math.min(truck.userData.speed + ACCELERATION * accelFactor, MAX_SPEED);
        } else if (keys['arrowdown']) {
            if (speed > 0.1) {
                // Braking when going forward - stronger braking effect
                truck.userData.speed *= 0.9;
            } else {
                // Reverse acceleration
                truck.userData.speed = Math.max(truck.userData.speed - ACCELERATION, -MAX_REVERSE_SPEED);
            }
        } else {
            // Natural deceleration - more gradual
            truck.userData.speed *= 0.98;
            
            // Eliminate tiny speeds
            if (Math.abs(truck.userData.speed) < 0.01) {
                truck.userData.speed = 0;
            }
        }
        
        // Handle drifting effect for more fun driving
        // Direction of travel isn't exactly the direction the truck is facing
        let moveX, moveZ;
        
        if (Math.abs(truck.userData.speed) > 0.5) {
            // At speed, allow some drift
            const driftDirection = oldDirection;
            
            // Blend actual direction with drift direction
            moveX = (dirX * truck.userData.speed * (1 - DRIFT_FACTOR)) + 
                   (Math.sin(driftDirection) * truck.userData.speed * DRIFT_FACTOR);
            moveZ = (dirZ * truck.userData.speed * (1 - DRIFT_FACTOR)) + 
                   (Math.cos(driftDirection) * truck.userData.speed * DRIFT_FACTOR);
        } else {
            // At low speeds, no drift
            moveX = dirX * truck.userData.speed;
            moveZ = dirZ * truck.userData.speed;
        }
        
        // Store previous position for collision detection
        const prevX = truck.position.x;
        const prevZ = truck.position.z;
        
        // Update truck position with momentum
        truck.position.x += moveX;
        truck.position.z += moveZ;
        
        // Animate wheels based on speed
        if (truck.userData.wheels) {
            truck.userData.wheels.forEach(wheel => {
                wheel.rotation += truck.userData.speed * 0.2;
            });
        }
        
        // Only allow rotation around y-axis (steering)
        truck.rotation.x = 0;
        truck.rotation.z = 0;
        
        // Update wheel steering to match direction
        if (truck.userData.wheels) {
            truck.userData.wheels.forEach(wheel => {
                if (wheel.steering) {
                    // Visualize steering by rotating front wheels relative to truck
                    // The steering wheels turn in the direction of the turn
                    const steeringAmount = Math.sin(truck.userData.direction - oldDirection) * 5;
                    const steeringDirection = keys['arrowleft'] ? 0.4 : 
                                            keys['arrowright'] ? -0.4 : 
                                            steeringAmount;
                    
                    // Apply smooth steering transition
                    const currentSteering = wheel.group.rotation.y || 0;
                    const newSteering = currentSteering * 0.8 + steeringDirection * 0.2;
                    wheel.group.rotation.y = newSteering;
                }
                
                // Rotate wheels based on speed
                wheel.rotation += truck.userData.speed * 0.2;
                wheel.mesh.rotation.x = wheel.rotation;
            });
        }
        
        // Simple boundary collision - just reverse direction
        const boundaryLimit = 350; // Slightly smaller than the actual boundary walls
        
        let hitBoundary = false;
        
        // Check X boundary (East/West walls)
        if (Math.abs(truck.position.x) > boundaryLimit) {
            hitBoundary = true;
            
            // Place truck at boundary limit
            truck.position.x = Math.sign(truck.position.x) * boundaryLimit;
        }
        
        // Check Z boundary (North/South walls)
        if (Math.abs(truck.position.z) > boundaryLimit) {
            hitBoundary = true;
            
            // Place truck at boundary limit
            truck.position.z = Math.sign(truck.position.z) * boundaryLimit;
        }
        
        // If hit a boundary, simply reverse direction
        if (hitBoundary) {
            // Simply reverse the speed (direction stays the same)
            truck.userData.speed = -truck.userData.speed * 0.8;
            
            // Add a small bounce effect
            truck.position.y += 0.4;
            
            // Add score for wall hit
            score += 10;
            document.getElementById('score').textContent = `SCORE: ${score}`;
            
            // Visual feedback - small bounce animation
            truck.userData.wallBounceTime = 8;
        }
        
        // Check for collision with big blocks (bounce off like walls)
        if (scene.userData.bigBlocks) {
            scene.userData.bigBlocks.forEach(block => {
                const dx = truck.position.x - block.position.x;
                const dz = truck.position.z - block.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const minDistance = block.size/2 + 3; // 3 is approximate truck radius
                
                if (distance < minDistance) {
                    // Collision detected
                    // Calculate normalized collision vector
                    const nx = dx / distance;
                    const nz = dz / distance;
                    
                    // Move truck outside the block
                    truck.position.x = block.position.x + nx * minDistance;
                    truck.position.z = block.position.z + nz * minDistance;
                    
                    // Bounce effect - reflect velocity
                    const bounceForce = 0.8;
                    truck.userData.speed *= -bounceForce;
                    
                    // Add score for block hit
                    score += 15;
                    document.getElementById('score').textContent = `SCORE: ${score}`;
                    
                    // Play crowd "oohs" sound
                    const crowdOohs = document.getElementById('crowdOohs');
                    crowdOohs.volume = 0.2;
                    crowdOohs.currentTime = 0;
                    crowdOohs.play().catch(e => console.log("Audio play failed: ", e));
                    
                    // Visual feedback - bounce animation
                    truck.userData.wallBounceTime = 10;
                    
                    // Jump effect
                    truck.position.y += 0.6;
                }
            });
        }
        
        // Check collision with destructible obstacles
        if (scene.userData.destructibleObstacles) {
            scene.userData.destructibleObstacles.forEach(obstacle => {
                // Only check non-exploding obstacles
                if (!obstacle.exploding && obstacle.mainBox.visible) {
                    const obstacleWorldPos = new THREE.Vector3();
                    obstacle.group.getWorldPosition(obstacleWorldPos);
                    
                    const dx = truck.position.x - obstacleWorldPos.x;
                    const dz = truck.position.z - obstacleWorldPos.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    const minDistance = obstacle.size/2 + 3; // 3 is approximate truck radius
                    
                    if (distance < minDistance) {
                        // Collision detected - start explosion
                        obstacle.exploding = true;
                        obstacle.explosionTime = 0;
                        
                        // Hide the main box
                        obstacle.mainBox.visible = false;
                        
                        // Show the explosion pieces
                        obstacle.pieces.forEach(piece => {
                            piece.mesh.visible = true;
                            piece.mesh.position.set(0, 0, 0);
                            piece.mesh.material.opacity = 1;
                        });
                        
                        // Slow down the truck slightly
                        truck.userData.speed *= 0.8;
                        
                        // Add score for destroying obstacle
                        score += 25;
                        document.getElementById('score').textContent = `SCORE: ${score}`;
                        
                        // Play crowd cheers sound
                        const crowdCheers = document.getElementById('crowdCheers');
                        crowdCheers.volume = 0.3;
                        crowdCheers.currentTime = 0;
                        crowdCheers.play().catch(e => console.log("Audio play failed: ", e));
                        
                        // Visual feedback
                        truck.userData.wallBounceTime = 5;
                    }
                }
            });
        }
        
        // Update exploding obstacles
        if (scene.userData.destructibleObstacles) {
            scene.userData.destructibleObstacles.forEach(obstacle => {
                if (obstacle.exploding) {
                    obstacle.explosionTime++;
                    
                    // Update each piece
                    obstacle.pieces.forEach(piece => {
                        // Move pieces outward
                        piece.mesh.position.x += piece.direction.x * 0.3;
                        piece.mesh.position.y += piece.direction.y * 0.3 + 0.05; // Add some upward movement
                        piece.mesh.position.z += piece.direction.z * 0.3;
                        
                        // Rotate pieces
                        piece.mesh.rotateOnAxis(piece.rotationAxis, piece.rotationSpeed);
                        
                        // Fade out pieces
                        if (obstacle.explosionTime > obstacle.explosionDuration / 2) {
                            const fadeProgress = (obstacle.explosionTime - obstacle.explosionDuration / 2) / (obstacle.explosionDuration / 2);
                            piece.mesh.material.opacity = 1 - fadeProgress;
                        }
                    });
                    
                    // Remove obstacle once explosion is complete
                    if (obstacle.explosionTime >= obstacle.explosionDuration) {
                        obstacle.pieces.forEach(piece => {
                            piece.mesh.visible = false;
                        });
                        obstacle.exploding = false;
                    }
                }
            });
        }
        
        // Find and update height based on driving up ramps
        let onRamp = false;
        let rampHeight = 0;
        let rampBounce = 0;
        
        // Check if on any of the large ramps
        if (truck.position.x >= 75 && truck.position.x <= 125 && 
            truck.position.z >= 135 && truck.position.z <= 165) {
            // On ramp 1
            onRamp = true;
            const rampProgress = Math.abs((truck.position.z - 150) / 15);
            rampHeight = 10 * (1 - rampProgress);
        } 
        else if (truck.position.x >= -150 && truck.position.x <= -90 && 
                 truck.position.z >= -200 && truck.position.z <= -160) {
            // On ramp 2
            onRamp = true;
            const rampProgress = Math.abs((truck.position.z - (-180)) / 20);
            rampHeight = 16 * (1 - rampProgress);
        }
        else if (truck.position.x >= -75 && truck.position.x <= -25 && 
                 truck.position.z >= 180 && truck.position.z <= 220) {
            // On ramp 3
            onRamp = true;
            const rampProgress = Math.abs((truck.position.z - 200) / 20);
            rampHeight = 12 * (1 - rampProgress);
        }
        else if (truck.position.x >= 175 && truck.position.x <= 225 && 
                 truck.position.z >= -120 && truck.position.z <= -80) {
            // On ramp 4
            onRamp = true;
            const rampProgress = Math.abs((truck.position.z - (-100)) / 20);
            rampHeight = 14 * (1 - rampProgress);
        }
        
        if (onRamp) {
            // Set truck height based on ramp position
            if (truck.userData.wasOnRamp) {
                // Already on ramp, smooth movement
                truck.position.y = 2 + rampHeight;
            } else {
                // Just hit the ramp - add bounce proportional to speed
                rampBounce = Math.abs(truck.userData.speed) * 0.8;
                truck.position.y = 2 + rampHeight + rampBounce;
            }
            
            // Remember we're on a ramp
            truck.userData.wasOnRamp = true;
            
            // Add score when on ramps
            if (rampHeight > 5) {
                score += 1;
                document.getElementById('score').textContent = `SCORE: ${score}`;
                
                // Occasionally play crowd cheers when on ramps
                if (Math.random() < 0.01) {
                    const crowdCheers = document.getElementById('crowdCheers');
                    crowdCheers.volume = 0.2;
                    crowdCheers.currentTime = 0;
                    crowdCheers.play().catch(e => console.log("Audio play failed: ", e));
                }
            }
        } else {
            // Not on a ramp - normal height plus any active bounce effects
            truck.position.y = 2;
            truck.userData.wasOnRamp = false;
        }
        
        // Handle bounce oscillation effect if active
        if (truck.userData.wallBounceTime > 0) {
            truck.position.y += Math.sin(truck.userData.wallBounceTime * 0.5) * 0.1;
            truck.userData.wallBounceTime--;
        }
        
        // Add a subtle "bounce" effect when changing direction at speed
        if (Math.abs(truck.userData.speed) > 0.5) {
            // If turning sharply at speed, adjust truck height slightly
            const turnSharpness = Math.abs(truck.userData.direction - truck.userData.lastDirection || 0);
            
            if (turnSharpness > 0.01) {
                // Add a tiny bounce proportional to turn sharpness and speed
                truck.position.y += Math.min(0.2, turnSharpness * Math.abs(truck.userData.speed) * 0.1);
            }
        }
        
        // Remember current direction for next frame
        truck.userData.lastDirection = truck.userData.direction;
    }
    
    function updateCamera() {
        // Update camera settings based on keys
        if (keys['w']) cameraSettings.height += 0.5;
        if (keys['s']) cameraSettings.height = Math.max(5, cameraSettings.height - 0.5);
        if (keys['a']) cameraSettings.distance = Math.max(10, cameraSettings.distance - 0.5);
        if (keys['d']) cameraSettings.distance += 0.5;
        
        updateCameraPosition();
    }
    
    function updateCameraPosition() {
        // Only update if truck exists
        if (!truck) return;
        
        // Calculate camera position based on truck direction and camera settings
        const truckPos = truck.position;
        const truckDir = truck.rotation.y; // Use actual truck rotation now
        
        // Position camera behind truck
        const cameraX = truckPos.x - Math.sin(truckDir) * cameraSettings.distance;
        const cameraZ = truckPos.z - Math.cos(truckDir) * cameraSettings.distance;
        const cameraY = truckPos.y + cameraSettings.height;
        
        // Smoothly move camera (interpolate for smoother following)
        camera.position.x = camera.position.x * 0.92 + cameraX * 0.08;
        camera.position.y = camera.position.y * 0.92 + cameraY * 0.08;
        camera.position.z = camera.position.z * 0.92 + cameraZ * 0.08;
        
        // Look at truck with slight offset
        camera.lookAt(
            truckPos.x, 
            truckPos.y + 2, 
            truckPos.z
        );
    }
    
    function animate() {
        requestAnimationFrame(animate);
        
        try {
            // Only run updates after everything is initialized
            if (truck && camera && renderer) {
                // Update truck
                updateTruck();
                
                // Update camera
                updateCamera();
                
                // Render
                renderer.render(scene, camera);
            }
        } catch (error) {
            console.error("Animation error:", error);
        }
    }
    
    // Start the game
    init();
    </script>
</body>
</html>