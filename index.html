<!DOCTYPE html>
<html>
<head>
    <title>Monster Truck Game - Realistic Controls</title>
    <link rel="icon" href="data:,">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #120023;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            color: #fff;
            text-align: center;
            z-index: 100;
            font-size: 16px;
            text-shadow: 0 0 5px #ff00ff;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ff00ff;
            font-size: 14px;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #00ffff;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ff00ff;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="info">
        Monster Truck - Realistic Controls Edition
    </div>
    
    <div id="controls">
        <p>Up/Down: Accelerate/Brake</p>
        <p>Left/Right: Steer</p>
        <p>W/S: Camera Height</p>
        <p>A/D: Camera Distance</p>
    </div>
    
    <div id="score">SCORE: 0</div>
    
    <div style="position: absolute; bottom: 20px; right: 20px; color: #fff; background-color: rgba(0, 0, 0, 0.6); padding: 10px; border-radius: 5px; border: 1px solid #ff00ff;">
        <label for="musicToggle" style="cursor: pointer; user-select: none;">
            <input type="checkbox" id="musicToggle" checked> 80s Synthwave
        </label>
        <input type="range" id="volumeSlider" min="0" max="100" value="50" style="width: 100px; margin-left: 10px;">
    </div>

    <!-- Audio elements for MP3 playback -->
    <audio id="bgMusic" loop preload="auto">
        <source src="Micah Smith - Bubble Bath.mp3" type="audio/mpeg">
    </audio>
    
    <!-- Music selection prompt -->
    <div id="musicPrompt" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
         background-color: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; border: 2px solid #ff00ff; 
         color: white; text-align: center; display: none; z-index: 1000;">
        <h3 style="color: #00ffff; margin-top: 0;">Choose Music Option</h3>
        <button id="startMp3Btn" style="background: #ff00ff; color: white; border: none; padding: 10px 20px; 
                margin: 10px; cursor: pointer; border-radius: 5px; display: block; width: 200px;">
            MP3 Track
        </button>
        <button id="startGeneratedBtn" style="background: #00ffff; color: black; border: none; padding: 10px 20px; 
                margin: 10px; cursor: pointer; border-radius: 5px; display: block; width: 200px;">
            Generated Synthwave
        </button>
        <button id="startNoMusicBtn" style="background: #333; color: white; border: none; padding: 10px 20px; 
                margin: 10px; cursor: pointer; border-radius: 5px; display: block; width: 200px;">
            No Music
        </button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // Improved monster truck game with realistic driving controls
    let scene, camera, renderer, truck;
    let score = 0;
    let groundMeshes = [];
    
    // Control variables
    const keys = {};
    const truckSpeed = {
        x: 0,
        z: 0
    };
    
    // Camera settings
    const cameraSettings = {
        height: 20,
        distance: 30,
        angle: 0.3
    };
    
    function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x120023); // Dark purple background
        
        // Create camera with angled view
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 30); // Set initial position directly
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xff00ff, 0.8);
        directionalLight.position.set(0, 50, 20);
        scene.add(directionalLight);
        
        // Create ground with grid
        createGround();
        
        // Create obstacles
        createObstacles();
        
        // Create boundary walls
        createBoundary();
        
        // Create the monster truck
        createTruck();
        
        // Set up controls
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize);
        
        // Set up music controls
        setupMusic();
        
        // Start animation loop
        animate();
    }
    
    // Music system variables
    let audioContext = null;
    let gainNode = null;
    let oscillator = null;
    let musicPlaying = false;
    let musicMode = 'none'; // 'mp3', 'generated', or 'none'
    
    function setupMusic() {
        const musicToggle = document.getElementById('musicToggle');
        const volumeSlider = document.getElementById('volumeSlider');
        const musicPrompt = document.getElementById('musicPrompt');
        const startMp3Btn = document.getElementById('startMp3Btn');
        const startGeneratedBtn = document.getElementById('startGeneratedBtn');
        const startNoMusicBtn = document.getElementById('startNoMusicBtn');
        const bgMusic = document.getElementById('bgMusic');
        
        // Set toggle to not checked initially
        musicToggle.checked = false;
        
        // Set initial volume
        bgMusic.volume = volumeSlider.value / 100;
        
        // Make sure all DOM elements exist before showing prompt
        if (musicPrompt && startMp3Btn && startGeneratedBtn && startNoMusicBtn) {
            // Show music prompt after a short delay
            setTimeout(() => {
                musicPrompt.style.display = 'block';
            }, 500);
        } else {
            console.error("Missing music UI elements");
        }
        
        // Safely set up event listeners
        if (startMp3Btn) {
            startMp3Btn.addEventListener('click', () => {
                if (musicPrompt) musicPrompt.style.display = 'none';
                musicMode = 'mp3';
                startMp3Music();
                if (musicToggle) musicToggle.checked = true;
            });
        }
        
        if (startGeneratedBtn) {
            startGeneratedBtn.addEventListener('click', () => {
                if (musicPrompt) musicPrompt.style.display = 'none';
                musicMode = 'generated';
                startSynthMusic();
                if (musicToggle) musicToggle.checked = true;
            });
        }
        
        if (startNoMusicBtn) {
            startNoMusicBtn.addEventListener('click', () => {
                if (musicPrompt) musicPrompt.style.display = 'none';
                musicMode = 'none';
                if (musicToggle) musicToggle.checked = false;
            });
        }
        
        // Toggle music on/off
        if (musicToggle) {
            musicToggle.addEventListener('change', () => {
                if (musicToggle.checked) {
                    // Resume current music mode or default to MP3
                    if (musicMode === 'generated') {
                        if (!musicPlaying) startSynthMusic();
                    } else {
                        // Default to MP3 if no mode selected yet
                        if (musicMode === 'none') musicMode = 'mp3';
                        startMp3Music();
                    }
                } else {
                    // Stop all music
                    stopAllMusic();
                }
            });
            
            // Add music type selector - right-click toggles between MP3 and generated
            musicToggle.addEventListener('contextmenu', (e) => {
                e.preventDefault(); // Prevent context menu
                
                if (musicToggle.checked) {
                    stopAllMusic();
                    
                    // Toggle between MP3 and generated
                    if (musicMode === 'mp3') {
                        musicMode = 'generated';
                        startSynthMusic();
                    } else {
                        musicMode = 'mp3';
                        startMp3Music();
                    }
                }
                
                return false;
            });
        }
        
        // Adjust volume for both audio systems
        if (volumeSlider && bgMusic) {
            volumeSlider.addEventListener('input', () => {
                const volume = volumeSlider.value / 100;
                
                // For Web Audio API
                if (gainNode) {
                    gainNode.gain.value = volume;
                }
                
                // For HTML5 Audio
                bgMusic.volume = volume;
            });
        }
    }
    
    function startMp3Music() {
        // Stop any generated music first
        stopSynthMusic();
        
        // Play the MP3
        const bgMusic = document.getElementById('bgMusic');
        
        try {
            const playPromise = bgMusic.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.log("MP3 playback failed:", error);
                    
                    // If MP3 fails, fall back to generated music
                    musicMode = 'generated';
                    startSynthMusic();
                });
            }
        } catch (e) {
            console.error("MP3 playback error:", e);
            
            // If MP3 fails, fall back to generated music
            musicMode = 'generated';
            startSynthMusic();
        }
    }
    
    function stopAllMusic() {
        // Stop MP3
        const bgMusic = document.getElementById('bgMusic');
        bgMusic.pause();
        bgMusic.currentTime = 0;
        
        // Stop generated music
        stopSynthMusic();
    }
    
    // Generate synthwave-like music programmatically using Web Audio API
    function startSynthMusic() {
        try {
            // Create audio context if it doesn't exist
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create gain node for volume control
                gainNode = audioContext.createGain();
                gainNode.gain.value = document.getElementById('volumeSlider').value / 100;
                gainNode.connect(audioContext.destination);
            }
            
            // Create synthwave-like bass
            createSynthBassPart();
            
            // Create synthwave-like lead arpeggio
            setTimeout(() => {
                createSynthLeadPart();
            }, 1000);
            
            musicPlaying = true;
        } catch (e) {
            console.error("Web Audio API error:", e);
        }
    }
    
    function createSynthBassPart() {
        // Base notes for synthwave
        const notes = [
            { note: 55, duration: 0.5 }, // G
            { note: 55, duration: 0.5 },
            { note: 62, duration: 0.5 }, // D
            { note: 55, duration: 0.5 },
            { note: 58, duration: 0.5 }, // A#
            { note: 55, duration: 0.5 },
            { note: 53, duration: 0.5 }, // F
            { note: 55, duration: 0.5 }
        ];
        
        let currentIndex = 0;
        
        function playNextNote() {
            if (!musicPlaying) return;
            
            const note = notes[currentIndex];
            const osc = audioContext.createOscillator();
            const noteGain = audioContext.createGain();
            
            // Set up oscillator
            osc.type = 'sawtooth';
            osc.frequency.value = note.note;
            
            // Set up envelope
            noteGain.gain.value = 0;
            noteGain.gain.setValueAtTime(0, audioContext.currentTime);
            noteGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01);
            noteGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.2);
            noteGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + note.duration);
            
            // Connect nodes
            osc.connect(noteGain);
            noteGain.connect(gainNode);
            
            // Play note
            osc.start();
            osc.stop(audioContext.currentTime + note.duration);
            
            // Schedule next note
            currentIndex = (currentIndex + 1) % notes.length;
            setTimeout(playNextNote, note.duration * 1000);
        }
        
        // Start playing
        playNextNote();
    }
    
    function createSynthLeadPart() {
        // Lead notes for synthwave arpeggio
        const notes = [
            { note: 440, duration: 0.125 }, // A4
            { note: 554, duration: 0.125 }, // C#5
            { note: 659, duration: 0.125 }, // E5
            { note: 880, duration: 0.125 }, // A5
            { note: 659, duration: 0.125 }, // E5
            { note: 554, duration: 0.125 }, // C#5
            { note: 440, duration: 0.125 }, // A4
            { note: 329, duration: 0.125 }  // E4
        ];
        
        let currentIndex = 0;
        
        function playNextNote() {
            if (!musicPlaying) return;
            
            const note = notes[currentIndex];
            const osc = audioContext.createOscillator();
            const noteGain = audioContext.createGain();
            
            // Set up oscillator
            osc.type = 'square';
            osc.frequency.value = note.note;
            
            // Set up envelope
            noteGain.gain.value = 0;
            noteGain.gain.setValueAtTime(0, audioContext.currentTime);
            noteGain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
            noteGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + note.duration);
            
            // Connect nodes
            osc.connect(noteGain);
            noteGain.connect(gainNode);
            
            // Play note
            osc.start();
            osc.stop(audioContext.currentTime + note.duration);
            
            // Schedule next note
            currentIndex = (currentIndex + 1) % notes.length;
            setTimeout(playNextNote, note.duration * 1000);
        }
        
        // Start playing
        playNextNote();
    }
    
    function stopSynthMusic() {
        musicPlaying = false;
    }
    
    function createGround() {
        // Create a large flat ground
        const groundSize = 200;
        
        // Solid ground
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x000000, 
            side: THREE.DoubleSide
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);
        groundMeshes.push(ground);
        
        // Grid lines
        const gridGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 50, 50);
        const gridMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff,
            wireframe: true,
            transparent: true,
            opacity: 0.5
        });
        const grid = new THREE.Mesh(gridGeometry, gridMaterial);
        grid.rotation.x = -Math.PI / 2;
        grid.position.y = 0.1;
        scene.add(grid);
        groundMeshes.push(grid);
    }
    
    function createObstacles() {
        // Create a ramp
        const rampGeometry = new THREE.BoxGeometry(20, 5, 10);
        const rampMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff });
        const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
        ramp.position.set(0, 2.5, 30);
        ramp.rotation.x = -Math.PI / 20; // Gentle slope
        scene.add(ramp);
        groundMeshes.push(ramp);
        
        // Add random boxes as obstacles
        for (let i = 0; i < 10; i++) {
            const size = 2 + Math.random() * 3;
            const x = (Math.random() - 0.5) * 160;
            const z = (Math.random() - 0.5) * 160;
            
            if (Math.abs(x) > 20 || Math.abs(z) > 20) { // Don't place too close to spawn
                const boxGeometry = new THREE.BoxGeometry(size, size, size);
                const boxMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff });
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                box.position.set(x, size/2, z);
                scene.add(box);
                groundMeshes.push(box);
            }
        }
    }
    
    function createBoundary() {
        // Create a boundary around the game field
        const boundarySize = 180; // Slightly smaller than the ground
        const wallHeight = 15;
        const wallThickness = 2;
        
        // Define the boundary material with gradient effect
        const boundaryMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff00ff,
            transparent: true,
            opacity: 0.5,
            emissive: 0x330033,
            shininess: 100
        });
        
        // Create each wall segment
        const walls = [
            // North wall
            { pos: [0, wallHeight/2, -boundarySize/2], size: [boundarySize, wallHeight, wallThickness] },
            // South wall
            { pos: [0, wallHeight/2, boundarySize/2], size: [boundarySize, wallHeight, wallThickness] },
            // East wall
            { pos: [boundarySize/2, wallHeight/2, 0], size: [wallThickness, wallHeight, boundarySize] },
            // West wall
            { pos: [-boundarySize/2, wallHeight/2, 0], size: [wallThickness, wallHeight, boundarySize] }
        ];
        
        // Create all walls
        walls.forEach(wall => {
            const geometry = new THREE.BoxGeometry(wall.size[0], wall.size[1], wall.size[2]);
            const mesh = new THREE.Mesh(geometry, boundaryMaterial);
            mesh.position.set(wall.pos[0], wall.pos[1], wall.pos[2]);
            scene.add(mesh);
            groundMeshes.push(mesh);
            
            // Add glowing edge at the top of each wall
            const edgeGeometry = new THREE.BoxGeometry(wall.size[0] + 0.5, 0.5, wall.size[2] + 0.5);
            const edgeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
            edge.position.set(wall.pos[0], wallHeight, wall.pos[2]);
            scene.add(edge);
        });
    }
    
    function createTruck() {
        // Create a better-looking truck, but still with NO ROTATION
        truck = new THREE.Group();
        
        // Chassis with improved visuals
        const chassisGeometry = new THREE.BoxGeometry(4.5, 1, 8);
        const chassisMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff00ff,
            shininess: 80,
            specular: 0xffffff
        });
        const chassis = new THREE.Mesh(chassisGeometry, chassisMaterial);
        chassis.position.y = 0.5;
        truck.add(chassis);
        
        // Add neon trim to chassis
        const trimGeometry = new THREE.BoxGeometry(4.6, 0.1, 8.1);
        const trimMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const trim = new THREE.Mesh(trimGeometry, trimMaterial);
        trim.position.y = 1.05;
        truck.add(trim);
        
        // Cab with better detailing
        const cabGeometry = new THREE.BoxGeometry(4, 1.5, 3);
        const cabMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff00ff,
            shininess: 90,
            specular: 0xffffff
        });
        const cab = new THREE.Mesh(cabGeometry, cabMaterial);
        cab.position.set(0, 1.5, -2);
        truck.add(cab);
        
        // Windshield
        const windshieldGeometry = new THREE.PlaneGeometry(3.5, 1.2);
        const windshieldMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const windshield = new THREE.Mesh(windshieldGeometry, windshieldMaterial);
        windshield.position.set(0, 1.8, -3.2);
        windshield.rotation.x = 0.3;
        truck.add(windshield);
        
        // Add headlights
        const headlightGeometry = new THREE.SphereGeometry(0.4, 16, 16);
        const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        // Left headlight
        const leftHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
        leftHeadlight.position.set(-1.5, 0.8, -4);
        truck.add(leftHeadlight);
        
        // Right headlight
        const rightHeadlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
        rightHeadlight.position.set(1.5, 0.8, -4);
        truck.add(rightHeadlight);
        
        // Create spinning wheels that can animate
        const wheelRadius = 1.4;
        const wheelWidth = 1.0;
        const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth, 24);
        const wheelMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x333333,
            shininess: 30
        });
        
        // Wheel hub material
        const hubGeometry = new THREE.CylinderGeometry(wheelRadius * 0.5, wheelRadius * 0.5, wheelWidth + 0.1, 16);
        const hubMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xdddddd,
            shininess: 100,
            specular: 0xffffff
        });
        
        // Store wheel references
        truck.userData.wheels = [];
        
        const wheelPositions = [
            {x: -2.2, y: wheelRadius, z: -3, steering: true}, // Front left
            {x: 2.2, y: wheelRadius, z: -3, steering: true},  // Front right
            {x: -2.2, y: wheelRadius, z: 3, steering: false}, // Rear left
            {x: 2.2, y: wheelRadius, z: 3, steering: false}   // Rear right
        ];
        
        wheelPositions.forEach(pos => {
            // Create wheel group
            const wheelGroup = new THREE.Group();
            wheelGroup.position.set(pos.x, pos.y, pos.z);
            
            // Create wheel mesh
            const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel.rotation.z = Math.PI / 2; // Correct wheel orientation
            wheelGroup.add(wheel);
            
            // Add hub cap
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            hub.rotation.z = Math.PI / 2;
            wheelGroup.add(hub);
            
            // Add wheel group to truck
            truck.add(wheelGroup);
            
            // Store wheel reference
            truck.userData.wheels.push({
                group: wheelGroup,
                mesh: wheel,
                steering: pos.steering,
                rotation: 0
            });
        });
        
        // Add fancy neon underglow
        const glowGeometry = new THREE.PlaneGeometry(6, 10);
        const glowMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.rotation.x = Math.PI / 2;
        glow.position.y = -0.5;
        truck.add(glow);
        
        // Set initial position
        truck.position.set(0, 2, 0);
        
        // Make sure there's absolutely no rotation initially
        truck.rotation.set(0, 0, 0);
        
        // Add to scene
        scene.add(truck);
        
        // Add properties for movement
        truck.userData = {
            speed: 0,
            direction: 0, // Direction in radians
            height: 2,    // Height above ground
            onGround: true,
            wasOnRamp: false,
            wheels: truck.userData.wheels
        };
    }
    
    function onKeyDown(event) {
        keys[event.key.toLowerCase()] = true;
    }
    
    function onKeyUp(event) {
        keys[event.key.toLowerCase()] = false;
    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function updateTruck() {
        // Enhanced driving constants for better feel
        const ACCELERATION = 0.08;       // Smoother acceleration
        const MAX_SPEED = 2.0;           // Higher top speed
        const MAX_REVERSE_SPEED = 1.0;   // Decent reverse speed
        const STEERING_SPEED = 0.04;     // Base steering rate
        const DRIFT_FACTOR = 0.92;       // Slight drift effect
        
        // Dynamic handling variables
        const speed = truck.userData.speed || 0;
        const speedPercent = Math.min(1, Math.abs(speed) / MAX_SPEED);
        
        // Get current direction and store old direction for drift calculations
        const oldDirection = truck.userData.direction || 0;
        let newDirection = oldDirection;
        
        // Changed controls: left/right arrows steer, up/down drive forward/backward
        // Steer only when moving or very slightly when stationary
        if (Math.abs(speed) > 0.1) {
            // Normal steering when moving
            const adaptiveSteering = STEERING_SPEED * (1 - speedPercent * 0.5);
            
            if (keys['arrowleft']) {
                newDirection += adaptiveSteering; // Turn left
            }
            if (keys['arrowright']) {
                newDirection -= adaptiveSteering; // Turn right
            }
        } else {
            // Very subtle steering when stationary
            if (keys['arrowleft']) {
                newDirection += STEERING_SPEED * 0.2; 
            }
            if (keys['arrowright']) {
                newDirection -= STEERING_SPEED * 0.2;
            }
        }
        
        // Add momentum to steering for smoother direction changes
        truck.userData.direction = oldDirection * 0.1 + newDirection * 0.9;
        
        // Actually ROTATE the truck model to match its direction
        truck.rotation.y = truck.userData.direction;
        
        // Calculate movement vectors - always relative to truck's current rotation
        // Forward is always the direction the truck is facing
        const dirX = Math.sin(truck.userData.direction);
        const dirZ = Math.cos(truck.userData.direction);
        
        // Enhanced acceleration with better responsiveness
        if (keys['arrowup']) {
            // Progressive acceleration - slower at start, quicker in the middle range
            const accelFactor = 1 - (Math.pow(speed / MAX_SPEED, 2) * 0.8);
            truck.userData.speed = Math.min(truck.userData.speed + ACCELERATION * accelFactor, MAX_SPEED);
        } else if (keys['arrowdown']) {
            if (speed > 0.1) {
                // Braking when going forward - stronger braking effect
                truck.userData.speed *= 0.9;
            } else {
                // Reverse acceleration
                truck.userData.speed = Math.max(truck.userData.speed - ACCELERATION, -MAX_REVERSE_SPEED);
            }
        } else {
            // Natural deceleration - more gradual
            truck.userData.speed *= 0.98;
            
            // Eliminate tiny speeds
            if (Math.abs(truck.userData.speed) < 0.01) {
                truck.userData.speed = 0;
            }
        }
        
        // Handle drifting effect for more fun driving
        // Direction of travel isn't exactly the direction the truck is facing
        let moveX, moveZ;
        
        if (Math.abs(truck.userData.speed) > 0.5) {
            // At speed, allow some drift
            const driftDirection = oldDirection;
            
            // Blend actual direction with drift direction
            moveX = (dirX * truck.userData.speed * (1 - DRIFT_FACTOR)) + 
                   (Math.sin(driftDirection) * truck.userData.speed * DRIFT_FACTOR);
            moveZ = (dirZ * truck.userData.speed * (1 - DRIFT_FACTOR)) + 
                   (Math.cos(driftDirection) * truck.userData.speed * DRIFT_FACTOR);
        } else {
            // At low speeds, no drift
            moveX = dirX * truck.userData.speed;
            moveZ = dirZ * truck.userData.speed;
        }
        
        // Update truck position with momentum
        truck.position.x += moveX;
        truck.position.z += moveZ;
        
        // Handle terrain and jumps - improved for better feel
        // Check if on ramp
        if (truck.position.z >= 25 && truck.position.z <= 35 && 
            truck.position.x >= -10 && truck.position.x <= 10) {
            
            // On the ramp - calculate height based on position with smoother curve
            const rampProgress = (30 - truck.position.z) / 5;
            const rampHeight = 0.5 + Math.max(0, Math.min(5, rampProgress * rampProgress * 6));
            
            // Set truck height and add a little bounce when hitting the ramp at speed
            if (truck.userData.wasOnRamp) {
                // Already on ramp, smooth movement
                truck.position.y = 1 + rampHeight;
            } else {
                // Just hit the ramp
                truck.position.y = 1 + rampHeight + (Math.abs(truck.userData.speed) * 0.5);
                
                // Jump effect when hitting ramp at speed
                if (Math.abs(truck.userData.speed) > 1.0) {
                    // Add a little "jump" at high speeds
                    truck.position.y += Math.abs(truck.userData.speed) * 0.2;
                }
            }
            
            // Remember we're on the ramp
            truck.userData.wasOnRamp = true;
            
            // Add score when on the ramp
            if (rampHeight > 2) {
                score += 1;
                document.getElementById('score').textContent = `SCORE: ${score}`;
            }
        } else {
            // Regular ground height
            truck.position.y = 2;
            truck.userData.wasOnRamp = false;
        }
        
        // Animate wheels based on speed
        if (truck.userData.wheels) {
            truck.userData.wheels.forEach(wheel => {
                wheel.rotation += truck.userData.speed * 0.2;
            });
        }
        
        // Only allow rotation around y-axis (steering)
        truck.rotation.x = 0;
        truck.rotation.z = 0;
        
        // Update wheel steering to match direction
        if (truck.userData.wheels) {
            truck.userData.wheels.forEach(wheel => {
                if (wheel.steering) {
                    // Visualize steering by rotating front wheels relative to truck
                    // The steering wheels turn in the direction of the turn
                    const steeringAmount = Math.sin(truck.userData.direction - oldDirection) * 5;
                    const steeringDirection = keys['arrowleft'] ? 0.4 : 
                                            keys['arrowright'] ? -0.4 : 
                                            steeringAmount;
                    
                    // Apply smooth steering transition
                    const currentSteering = wheel.group.rotation.y || 0;
                    const newSteering = currentSteering * 0.8 + steeringDirection * 0.2;
                    wheel.group.rotation.y = newSteering;
                }
                
                // Rotate wheels based on speed
                wheel.rotation += truck.userData.speed * 0.2;
                wheel.mesh.rotation.x = wheel.rotation;
            });
        }
        
        // Simple boundary collision - just reverse direction
        const boundaryLimit = 88; // Slightly smaller than the actual boundary walls
        
        let hitBoundary = false;
        
        // Check X boundary (East/West walls)
        if (Math.abs(truck.position.x) > boundaryLimit) {
            hitBoundary = true;
            
            // Place truck at boundary limit
            truck.position.x = Math.sign(truck.position.x) * boundaryLimit;
        }
        
        // Check Z boundary (North/South walls)
        if (Math.abs(truck.position.z) > boundaryLimit) {
            hitBoundary = true;
            
            // Place truck at boundary limit
            truck.position.z = Math.sign(truck.position.z) * boundaryLimit;
        }
        
        // If hit a boundary, simply reverse direction
        if (hitBoundary) {
            // Simply reverse the speed (direction stays the same)
            truck.userData.speed = -truck.userData.speed * 0.8;
            
            // Add a small bounce effect
            truck.position.y += 0.4;
            
            // Add score for wall hit
            score += 10;
            document.getElementById('score').textContent = `SCORE: ${score}`;
            
            // Visual feedback - small bounce animation
            truck.userData.wallBounceTime = 8;
        }
        
        // Handle bounce oscillation effect if active
        if (truck.userData.wallBounceTime > 0) {
            truck.position.y += Math.sin(truck.userData.wallBounceTime * 0.5) * 0.05;
            truck.userData.wallBounceTime--;
        }
        
        // Add a subtle "bounce" effect when changing direction at speed
        // This makes driving feel more dynamic without actually rotating the truck
        if (Math.abs(truck.userData.speed) > 0.5) {
            // If turning sharply at speed, adjust truck height slightly
            const turnSharpness = Math.abs(truck.userData.direction - truck.userData.lastDirection || 0);
            
            if (turnSharpness > 0.01) {
                // Add a tiny bounce proportional to turn sharpness and speed
                truck.position.y += Math.min(0.1, turnSharpness * Math.abs(truck.userData.speed) * 0.05);
            }
        }
        
        // Remember current direction for next frame
        truck.userData.lastDirection = truck.userData.direction;
    }
    
    function updateCamera() {
        // Update camera settings based on keys
        if (keys['w']) cameraSettings.height += 0.5;
        if (keys['s']) cameraSettings.height = Math.max(5, cameraSettings.height - 0.5);
        if (keys['a']) cameraSettings.distance = Math.max(10, cameraSettings.distance - 0.5);
        if (keys['d']) cameraSettings.distance += 0.5;
        
        updateCameraPosition();
    }
    
    function updateCameraPosition() {
        // Only update if truck exists
        if (!truck) return;
        
        // Calculate camera position based on truck direction and camera settings
        const truckPos = truck.position;
        const truckDir = truck.rotation.y; // Use actual truck rotation now
        
        // Position camera behind truck
        const cameraX = truckPos.x - Math.sin(truckDir) * cameraSettings.distance;
        const cameraZ = truckPos.z - Math.cos(truckDir) * cameraSettings.distance;
        const cameraY = truckPos.y + cameraSettings.height;
        
        // Smoothly move camera (interpolate for smoother following)
        camera.position.x = camera.position.x * 0.92 + cameraX * 0.08;
        camera.position.y = camera.position.y * 0.92 + cameraY * 0.08;
        camera.position.z = camera.position.z * 0.92 + cameraZ * 0.08;
        
        // Look at truck with slight offset
        camera.lookAt(
            truckPos.x, 
            truckPos.y + 2, 
            truckPos.z
        );
    }
    
    function animate() {
        requestAnimationFrame(animate);
        
        try {
            // Only run updates after everything is initialized
            if (truck && camera && renderer) {
                // Update truck
                updateTruck();
                
                // Update camera
                updateCamera();
                
                // Render
                renderer.render(scene, camera);
            }
        } catch (error) {
            console.error("Animation error:", error);
        }
    }
    
    // Start the game
    init();
    </script>
</body>
</html>